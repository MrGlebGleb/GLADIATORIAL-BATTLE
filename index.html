<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Арена Гладиаторов</title> <!-- Initial Title -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Orbitron:wght@500;700&display=swap');

        :root {
            --bg-color: #1e2227;
            --surface-color: #2b3036;
            --primary-color: #00ADB5;
            --primary-dark-color: #007A7F;
            --secondary-color: #EEEEEE;
            --text-color: #E0E0E0;
            --danger-color: #F44336;
            --warning-color: #FFC107;
            --enrage-color: #E91E63;
            --bonus-health-color: #8BC34A;
            --elite-weapon-color: #9C27B0;
            --armor-color: #607D8B; 
            --armor-block-color: #B0BEC5;
            --root-color: #795548;
            --slow-color: #607D8B;
            --poison-color: #4CAF50;
            --poison-effect-color: #388E3C;
            --modifier-color: #2196F3;
            --evasion-color: #B3E5FC;
            
            --tactical-int-color: #FF6B6B;
            --defense-int-color: #4ECDC4;
            --resource-int-color: #FFD166;
            --spatial-int-color: #118AB2;

            --font-main: 'Roboto', sans-serif;
            --font-title: 'Orbitron', sans-serif;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
            line-height: 1.6;
        }

        .container { display: flex; width: 100%; max-width: 1900px; gap: 25px; }
        
        .scoreboard { 
            background-color: var(--surface-color); 
            padding: 25px; 
            border-radius: 12px;
            width: 420px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.45);
            flex-shrink: 0; 
            display: flex; 
            flex-direction: column;
            border-top: 4px solid var(--primary-color);
        }
        
        .scoreboard h2 { 
            margin-top: 0; 
            text-align: center; 
            color: var(--primary-color); 
            font-size: 1.8em;
            font-family: var(--font-title);
            border-bottom: 2px solid var(--primary-dark-color); 
            padding-bottom: 15px; 
            margin-bottom: 20px; 
        }
        
        .scoreboard ul { list-style: none; padding: 0; flex-grow: 1; }
        
        .scoreboard li { 
            padding: 12px 10px;
            border-bottom: 1px solid #40454c;
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            font-size: 1.05em;
            transition: background-color 0.25s ease-in-out, transform 0.15s ease;
        }
        
        .scoreboard li:hover { 
            background-color: #353a40;
            transform: translateX(3px);
        }
        
        .scoreboard li:last-child { border-bottom: none; }
        
        .scoreboard .wins { 
            color: var(--warning-color); 
            font-weight: bold; 
            font-size: 1.2em; 
            margin-left: auto; 
            padding-left: 12px; 
        }
        
        .fighter-checkbox { margin-right: 12px; transform: scale(1.3); cursor: pointer; accent-color: var(--primary-color); }
        
        .fighter-intellect { display: flex; gap: 6px; margin-left: 12px; font-size: 0.9em; flex-shrink: 0; }
        .int-tactical, .int-defense, .int-resource, .int-spatial { font-weight:bold; }
        .int-tactical { color: var(--tactical-int-color); }
        .int-defense { color: var(--defense-int-color); }
        .int-resource { color: var(--resource-int-color); }
        .int-spatial { color: var(--spatial-int-color); }

        .main-content { flex-grow: 1; display: flex; flex-direction: column; gap: 25px; }
        .arena-container { display: flex; flex-direction: column; align-items: center; }

        .arena {
            background: #4a423c url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="50" height="50"><rect width="100" height="100" fill="%234a423c"/><path d="M20 20 H80 V80 H20Z M0 0 H100 V100 H0Z" stroke-width="0.3" stroke="rgba(0,0,0,0.15)" fill="none"/><circle cx="50" cy="50" r="35" stroke-width="0.3" stroke="rgba(0,0,0,0.15)" fill="none"/></svg>') center/cover;
            border: 8px solid #312a25;
            border-radius: 15px; width: 1000px; height: 700px; position: relative; margin: 10px auto; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.55), inset 0 0 15px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .fighter-on-arena {
            position: absolute; display: flex; flex-direction: column; align-items: center;
            width: 70px; height: 100px; 
            transition: transform 0.15s ease-in-out, opacity 0.3s ease-in-out, filter 0.2s, left 0.15s ease-in-out, top 0.15s ease-in-out;
            z-index: 5; cursor: default;
        }
        .fighter-on-arena.breathing { animation: breathing 2.5s ease-in-out infinite alternate; }
        @keyframes breathing {
            from { transform: scale(1); }
            to { transform: scale(1.03); }
        }
        
        .fighter-on-arena:hover .fighter-name-display { opacity: 1; transform: translateY(-4px) scale(1.08); }
        .fighter-on-arena:hover .int-action-hint { opacity: 1; }

        .fighter-on-arena::after { 
            content: ''; position: absolute; bottom: -12px; 
            left: 50%;
            transform: translateX(-50%); width: 45px; height: 10px;
            border-radius: 5px; opacity: 0; transition: opacity 0.3s ease-in-out;
        }
        .fighter-on-arena.is-rooted::after { background-color: var(--root-color); box-shadow: 0 0 10px var(--root-color); opacity: 0.85; }
        .fighter-on-arena.is-slowed::after { background-color: var(--slow-color); opacity: 0.75; width: 35px; height: 7px; }
        .fighter-on-arena.is-stunned img { animation: pulseStunned 0.4s infinite alternate; }
        
        @keyframes pulseStunned { 
            from { box-shadow: 0 0 10px 3px var(--warning-color); transform: rotate(-3deg) scale(0.98); } 
            to { box-shadow: 0 0 15px 5px var(--warning-color); transform: rotate(3deg) scale(1.02); } 
        }

        .fighter-on-arena .health-bar-container {
            width: 60px; height: 10px; background-color: #222; border: 1px solid #111;
            border-radius: 4px; margin-bottom: 2px; box-sizing: border-box; position: relative;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }
        .fighter-on-arena .health-bar {
            position: absolute; top: 1px; left: 1px; height: 6px;
            background-image: linear-gradient(to bottom, #66BB6A, #4CAF50);
            border-radius: 2px; transition: width 0.15s ease-out, background-image 0.15s ease-out;
        }
        .fighter-on-arena .health-bar.poisoned { background-image: linear-gradient(to bottom, var(--poison-color), var(--poison-effect-color)) !important; }

        .fighter-on-arena .armor-bar-container { 
            width: 60px; height: 6px; background-color: #222; border: 1px solid #111;
            border-radius: 3px; margin-bottom: 3px; box-sizing: border-box; position: relative;
            box-shadow: inset 0 1px 1px rgba(0,0,0,0.4); display: none; 
        }
        .fighter-on-arena .armor-bar {
            position: absolute; top: 1px; left: 1px; height: 2px; 
            background-image: linear-gradient(to bottom, var(--armor-color), #455A64);
            border-radius: 1px; transition: width 0.15s ease-out;
        }
        .fighter-on-arena.has-armor .armor-bar-container { display: block; }


        .fighter-on-arena img {
            width: 50px; height: 50px; border-radius: 50%;
            border: 3px solid #3a3f44; 
            object-fit: cover;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.5), 
                        0 4px 12px rgba(0,0,0,0.6); 
            background-color: #555; 
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.15s;
            margin-bottom: 2px;
        }
        .fighter-on-arena.has-intellect img {
            border-color: var(--primary-color); 
            box-shadow: inset 0 0 4px rgba(0,0,0,0.5), 
                        0 4px 12px rgba(0,0,0,0.6), 
                        0 0 12px 4px var(--primary-color); 
        }
        .fighter-on-arena.int-level-high img {
            border-color: #FFD700; 
            box-shadow: inset 0 0 4px rgba(0,0,0,0.5), 
                        0 4px 12px rgba(0,0,0,0.6), 
                        0 0 18px 6px #FFD700; 
        }
        .fighter-on-arena.enraged img { 
            border-color: var(--enrage-color); 
            box-shadow: 0 0 15px 4px var(--enrage-color); 
            animation: pulseEnrageShadow 0.6s infinite alternate; 
        }
        .fighter-on-arena.has-armor img { 
            border-color: var(--armor-color);
            box-shadow: inset 0 0 4px rgba(0,0,0,0.5), 
                        0 4px 12px rgba(0,0,0,0.6), 
                        0 0 10px 3px var(--armor-color); 
        }


        @keyframes pulseEnrageShadow { 
            from { box-shadow: 0 0 12px 3px var(--enrage-color); transform: scale(1.02); } 
            to { box-shadow: 0 0 20px 6px var(--enrage-color); transform: scale(1.05); } 
        }
        
        .fighter-on-arena .fighter-name-display { 
            font-size: 0.62em; color: var(--bg-color); 
            background-color: var(--primary-color); 
            padding: 2px 6px; border-radius: 4px; margin-top: 2px; 
            white-space: nowrap; font-weight: bold; opacity: 0.95; 
            transition: opacity 0.2s, transform 0.2s, background-color 0.2s; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.4); 
        }
        .fighter-on-arena.enraged .fighter-name-display { background-color: var(--enrage-color); color: var(--secondary-color); }
        
        .fighter-on-arena .weapon-emoji { font-size: 16px; margin-top: 2px; text-shadow: 0 0 3px rgba(0,0,0,0.5); }
        
        .fighter-on-arena.defeated { 
            opacity: 0.15; transform: rotate(85deg) scale(0.5) translateY(25px); 
            filter: grayscale(100%) blur(2px); z-index: 1 !important; 
        }
        
        .fighter-on-arena.attacking { transform: scale(1.15) translateY(-3px); }
        
        .fighter-on-arena.hit { animation: shakeHit 0.15s; }
        @keyframes shakeHit { 
            0%, 100% { transform: translate(0, 0) rotate(0deg); } 
            33% { transform: translate(-5px, 1px) rotate(-2.5deg); } 
            66% { transform: translate(5px, -1px) rotate(2.5deg); } 
        }
        
        .projectile { 
            position: absolute; font-size: 24px; z-index: 10; 
            transition: transform 0.12s ease-out, opacity 0.12s ease-out, left 0.12s ease-out, top 0.12s ease-out;
            text-shadow: 0 0 8px rgba(0,0,0,0.7); 
            filter: drop-shadow(0 0 3px rgba(255,255,255,0.5));
        }
        .projectile.hit-target { opacity: 0; transform: scale(2.2); }
        
        .battle-log { 
            background-color: var(--surface-color); padding: 20px; border-radius: 12px; 
            width: 100%; max-width: 1000px; height: 220px;
            overflow-y: auto; font-size: 0.95em; box-shadow: 0 8px 25px rgba(0,0,0,0.45); 
            border: 1px solid #40454c; border-top: 4px solid var(--primary-color);
        }
        .battle-log p { 
            margin: 6px 3px; padding: 8px 5px; border-bottom: 1px dashed #40454c;
            transition: background-color 0.2s;
        }
        .battle-log p:hover { background-color: #353a40; }
        .battle-log p:last-child { border-bottom: none; }
        
        .battle-log .log-damage { color: #FFA07A; }
        .battle-log .log-crit-damage { color: #FF4500; font-weight: bold; text-shadow: 0 0 6px #FF4500; }
        .battle-log .log-kill { color: var(--danger-color); font-weight: bold; }
        .battle-log .log-winner { color: var(--warning-color); font-weight: bold; font-size: 1.15em; }
        .battle-log .log-effect { color: var(--primary-color); font-style: italic; }
        .battle-log .log-poison { color: var(--poison-effect-color); font-weight: bold; }
        .battle-log .log-enrage { color: var(--enrage-color); font-weight: bold; font-style: italic; text-shadow: 0 0 4px var(--enrage-color); }
        .battle-log .log-bonus { color: var(--bonus-health-color); font-weight: bold; text-shadow: 0 0 4px var(--bonus-health-color);}
        .battle-log .log-elite-weapon { color: var(--elite-weapon-color); font-weight: bold; text-shadow: 0 0 6px var(--elite-weapon-color); }
        .battle-log .log-armor { color: var(--armor-color); font-weight: bold; text-shadow: 0 0 4px var(--armor-color); } 
        .battle-log .log-armor-block { color: var(--armor-block-color); font-style: italic; } 

        .battle-log .log-round-start { color: var(--primary-color); font-weight: bold; text-align: center; font-size: 1.2em; text-transform: uppercase; letter-spacing: 1px; }
        .battle-log .log-duel { color: var(--danger-color); font-weight: bold; text-align: center; font-size: 1.2em; }
        .battle-log .log-modifier { color: var(--modifier-color); font-weight: bold; font-style: italic; text-align: center; font-size: 1.12em; text-shadow: 0 0 5px var(--modifier-color); }
        .battle-log .log-evasion { color: var(--evasion-color); font-style: italic;}
        .battle-log .log-int-action { font-style: italic; opacity: 0.9; }
        .battle-log .log-int-tactical, .battle-log .log-int-defense, .battle-log .log-int-resource, .battle-log .log-int-spatial { font-weight: bold; }
        .battle-log .log-int-levelup { color: var(--primary-color); font-weight: bold; text-shadow: 0 0 6px var(--primary-color); font-size: 1.05em; }
        .battle-log .log-stall-restart { color: var(--warning-color); font-style: italic; text-align: center; font-weight: bold; }
        .battle-log p::before { 
            font-family: 'Arial'; margin-right: 8px; opacity: 0.7;
        }
        .battle-log .log-round-start::before { content: "⚔️"; }
        .battle-log .log-kill::before { content: "💀"; }
        .battle-log .log-winner::before { content: "🏆"; }
        .battle-log .log-int-levelup::before { content: "🧠"; }
        .battle-log .log-bonus::before, .battle-log .log-elite-weapon::before, .battle-log .log-armor::before { content: "✨"; }
        .battle-log .log-stall-restart::before { content: "⏳"; }

        h1 { 
            color: var(--primary-color); text-shadow: 2px 2px 6px rgba(0,0,0,0.7); 
            font-size: 3em; margin-bottom: 15px; text-transform: uppercase;
            font-family: var(--font-title); letter-spacing: 1.5px;
        }
        
        .game-controls { display: flex; gap: 15px; margin-bottom: 15px; align-items: center; }

        button#start-button, button#restart-round-button { 
            padding: 14px 32px; font-size: 1.4em; 
            background: linear-gradient(145deg, var(--primary-color), var(--primary-dark-color)); 
            color: var(--secondary-color); border: none; border-radius: 10px; 
            cursor: pointer; 
            transition: background 0.3s, transform 0.15s, box-shadow 0.3s; 
            font-weight: bold; box-shadow: 0 5px 15px rgba(0, 173, 181, 0.4); 
            text-transform: uppercase; letter-spacing: 1px;
        }
        button#start-button:hover:not(:disabled), button#restart-round-button:hover:not(:disabled) { 
            background: linear-gradient(145deg, #00c1cb, #008F95); 
            transform: translateY(-3px); box-shadow: 0 8px 20px rgba(0, 173, 181, 0.5);
        }
        button#start-button:active:not(:disabled), button#restart-round-button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 3px 10px rgba(0, 173, 181, 0.3); }
        button#start-button:disabled, button#restart-round-button:disabled { 
            background: #454c52; color: #888; cursor: not-allowed; box-shadow: none; 
        }
        button#restart-round-button {
            font-size: 1.1em; padding: 10px 20px;
            background: linear-gradient(145deg, var(--warning-color), #FFB300);
            box-shadow: 0 5px 15px rgba(255, 193, 7, 0.4);
        }
         button#restart-round-button:hover:not(:disabled) {
            background: linear-gradient(145deg, #FFD54F, #FFC107);
            box-shadow: 0 8px 20px rgba(255, 193, 7, 0.5);
        }

        
        .damage-flash {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 50%; 
            opacity: 0;
            animation: flashAnim 0.2s ease-out;
            pointer-events: none;
            z-index: 6; 
        }
        .damage-flash.normal { background-color: rgba(244, 67, 54, 0.5); }
        .damage-flash.critical { background-color: rgba(255, 193, 7, 0.6); }
        .damage-flash.blocked { background-color: rgba(120, 144, 156, 0.6); } 
        @keyframes flashAnim {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.5); }
        }

        .pickup-aura {
            position: absolute;
            width: 60px; height: 60px; 
            border-radius: 50%;
            opacity: 0;
            animation: pickupAuraAnim 0.5s ease-out;
            z-index: 4; 
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
        }
        .pickup-aura.health { background: radial-gradient(circle, rgba(139,195,74,0.6) 0%, rgba(139,195,74,0) 70%); }
        .pickup-aura.weapon { background: radial-gradient(circle, rgba(156,39,176,0.6) 0%, rgba(156,39,176,0) 70%); }
        .pickup-aura.armor { background: radial-gradient(circle, rgba(96,125,139,0.7) 0%, rgba(96,125,139,0) 70%); } 
        @keyframes pickupAuraAnim {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        .intellect-levelup-sparkle {
            position: absolute;
            width: 8px; height: 8px;
            background-color: var(--primary-color);
            border-radius: 50%;
            opacity: 0;
            animation: sparkleAnim 0.6s ease-out;
            z-index: 15;
            pointer-events: none;
        }
        @keyframes sparkleAnim {
            0%, 100% { opacity: 0; transform: translateY(0) scale(0.5); }
            50% { opacity: 1; transform: translateY(-20px) scale(1.2); }
        }


        .hit-spark { 
            position: absolute; width: 12px; height: 12px; 
            background-color: var(--warning-color); border-radius: 50%; 
            opacity: 0.9; transform: scale(1); 
            animation: hitSparkAnim 0.15s ease-out forwards; 
            z-index: 15; pointer-events: none; 
        }
        .hit-spark.critical { 
            background-color: var(--danger-color); width: 18px; height: 18px; 
            animation: critSparkAnim 0.18s ease-out forwards; 
        }
        .hit-spark.blocked { 
            background-color: var(--armor-block-color); width: 15px; height: 15px; 
            animation: blockSparkAnim 0.2s ease-out forwards; 
        }
        @keyframes hitSparkAnim { 
            0% { transform: scale(0.6); opacity: 0.9; } 
            50% { transform: scale(1.8); opacity: 0.5; } 
            100% { transform: scale(0.8); opacity: 0; } 
        }
        @keyframes critSparkAnim { 
            0% { transform: scale(0.7) rotate(0deg); opacity: 1; } 
            50% { transform: scale(2) rotate(60deg); opacity: 0.6; } 
            100% { transform: scale(0.9) rotate(120deg); opacity: 0; } 
        }
        @keyframes blockSparkAnim { 
            0% { transform: scale(0.5); opacity: 1; box-shadow: 0 0 5px 2px var(--armor-block-color); }
            50% { transform: scale(1.5); opacity: 0.7; box-shadow: 0 0 10px 4px var(--armor-block-color); }
            100% { transform: scale(0.7); opacity: 0; box-shadow: 0 0 5px 2px var(--armor-block-color); }
        }
        
        .aoe-indicator { 
            position: absolute; border: 4px dashed rgba(255, 100, 0, 0.8); 
            border-radius: 50%; opacity: 1; 
            animation: aoeFadeOut 0.25s ease-out forwards; 
            z-index: 3; pointer-events: none; box-sizing: border-box; 
        }
        @keyframes aoeFadeOut { 
            0% { opacity: 0.8; transform: scale(0.6); } 
            100% { opacity: 0; transform: scale(1.4); } 
        }
        
        .arena-bonus { 
            position: absolute; width: 40px; height: 40px; 
            border-radius: 50%; z-index: 4; display: flex; 
            align-items: center; justify-content: center; font-size: 22px; 
            box-shadow: 0 0 15px 5px rgba(255,255,255,0.6); 
            cursor: help; transition: transform 0.25s ease-in-out, box-shadow 0.25s; 
        }
        .arena-bonus:hover { transform: scale(1.15); box-shadow: 0 0 20px 7px rgba(255,255,255,0.75); }
        .arena-bonus.health-pack { 
            background-color: var(--bonus-health-color); border: 3px solid #689F38; 
            color: #1B5E20; font-weight: bold;
        }
        .arena-bonus.elite-weapon-pickup { 
            background-color: var(--elite-weapon-color); border: 3px solid #7B1FA2; 
            color: var(--secondary-color); font-size: 26px; 
            box-shadow: 0 0 18px 6px var(--elite-weapon-color); 
            animation: pulseEliteWeapon 0.8s infinite alternate; 
        }
        .arena-bonus.armor-pack { 
            background-color: var(--armor-color); border: 3px solid #37474F; 
            color: var(--secondary-color); font-weight: bold;
            animation: pulseArmorPack 1s infinite alternate;
        }
        @keyframes pulseEliteWeapon { 
            from { box-shadow: 0 0 15px 5px var(--elite-weapon-color); transform: scale(1); } 
            to { box-shadow: 0 0 25px 8px var(--elite-weapon-color); transform: scale(1.08); } 
        }
        @keyframes pulseArmorPack { 
            from { box-shadow: 0 0 12px 4px var(--armor-color); transform: scale(1); } 
            to { box-shadow: 0 0 20px 7px var(--armor-color); transform: scale(1.06); } 
        }


        #round-info-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: rgba(0, 0, 0, 0.9); z-index: 1000; 
            display: none; flex-direction: column; align-items: center; justify-content: center; 
            color: var(--secondary-color); padding: 20px; box-sizing: border-box; 
        }
        #round-info-overlay h2 { 
            color: var(--primary-color); font-size: 2.8em; margin-bottom: 20px; 
            text-transform: uppercase; border-bottom: 3px solid var(--primary-color); 
            padding-bottom: 12px; font-family: var(--font-title);
        }
        #round-info-overlay ul { 
            list-style: none; padding: 0; max-height: 65vh; overflow-y: auto; 
            text-align: left; background-color: var(--surface-color); 
            padding: 25px; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.6); 
            margin-bottom: 20px; width: 85%; max-width: 650px;
        }
        #round-info-overlay li { 
            font-size: 1.25em; margin-bottom: 14px; padding: 10px; 
            border-bottom: 1px solid #40454c; display: flex; align-items: center;
        }
        #round-info-overlay li:last-child { border-bottom: none; margin-bottom: 0; }
        #round-info-overlay .fighter-name-info { color: var(--warning-color); font-weight: bold; margin-right: 8px;}
        #round-info-overlay .fighter-intellect-info { font-size: 0.8em; margin-left: 8px; display: flex; gap: 4px;}
        #round-info-overlay .weapon-name-info { color: var(--secondary-color); margin-left: 8px;}
        #round-info-overlay .weapon-emoji-info { font-size: 1.35em; margin-left: 12px; }
        
        #place-bet-button { 
            padding: 12px 24px; font-size: 1.15em; background-color: var(--warning-color); 
            color: var(--bg-color); border: none; border-radius: 8px; cursor: pointer; 
            margin-top: 15px; display: none; font-weight: bold; transition: background-color 0.2s, transform 0.1s;
        }
        #place-bet-button:hover { background-color: #FFD54F; transform: translateY(-2px); }

        #betting-modal { 
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: rgba(0,0,0,0.94); z-index: 1001; 
            flex-direction: column; align-items: center; justify-content: center; 
            color: var(--secondary-color); padding: 20px; box-sizing: border-box; 
        }
        #betting-modal h2 { color: var(--primary-color); margin-bottom: 20px; font-family: var(--font-title); font-size: 2.2em;}
        #betting-modal p { margin: 8px 0; }
        #betting-modal label { margin-right: 12px; }
        #betting-modal select, #betting-modal input[type="number"] { 
            padding: 10px; font-size: 1.05em; border-radius: 6px; 
            border: 2px solid var(--primary-color); background-color: var(--surface-color); 
            color: var(--text-color); margin-bottom: 10px;
        }
        #betting-modal button { 
            padding: 12px 24px; font-size: 1.15em; border: none; border-radius: 8px; 
            cursor: pointer; font-weight: bold; margin-top: 15px; transition: background-color 0.2s, transform 0.1s;
        }
        #confirm-bet-button { background-color: var(--primary-color); color: var(--secondary-color); margin-right:15px; }
        #confirm-bet-button:hover { background-color: var(--primary-dark-color); transform: translateY(-2px); }
        #skip-bet-button { background-color: var(--surface-color); color: var(--primary-color); border: 2px solid var(--primary-color); }
        #skip-bet-button:hover { background-color: #40454c; transform: translateY(-2px); }
        
        #betting-payouts { 
            margin: 20px 0; font-size: 0.95em; text-align:left; 
            background-color: #2a2e33; padding:12px 18px; border-radius: 8px; 
            border: 1px solid var(--primary-color); 
        }
        #betting-payouts p { margin: 4px 0;}
        #bet-error-message { color: var(--danger-color); margin-top: 15px; font-weight: bold; }

        #buy-land-button {
            padding: 12px 18px; font-size: 1em; background-color: var(--warning-color);
            color: var(--bg-color); border: none; border-radius: 8px; cursor: pointer;
            margin-top: 20px; display: block; width: calc(100% - 0px); 
            box-sizing: border-box; font-weight: bold; transition: opacity 0.3s, background-color 0.2s, transform 0.1s;
        }
        #buy-land-button:hover:not(.disabled) { background-color: #FFD54F; transform: translateY(-2px); }
        #buy-land-button.disabled { opacity: 0.6; cursor: not-allowed; }

        #game-over-overlay { 
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(135deg, #FFB300, #FFD54F, #FFF8E1); 
            z-index: 2000; flex-direction: column; align-items: center; justify-content: center; 
            color: #424242; padding: 20px; box-sizing: border-box; text-align: center; 
        }
        #game-over-overlay h1 { 
            font-size: 4em; color: #A1887F; 
            text-shadow: 3px 3px 0px #fff, 4px 4px 8px rgba(0,0,0,0.4); 
            margin-bottom: 25px; font-family: var(--font-title);
        }
        #game-over-overlay p { font-size: 2.4em; color: #5D4037; font-weight: bold; }
        
        .int-action-hint {
            position: absolute; bottom: -16px; 
            left: 50%; transform: translateX(-50%);
            background-color: rgba(10, 10, 10, 0.8); color: white; padding: 3px 6px;
            border-radius: 4px; font-size: 0.6em; white-space: nowrap; opacity: 0;
            transition: opacity 0.3s; pointer-events: none; z-index: 10;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        
        @keyframes intellect-pulse {
            0% { box-shadow: 0 0 3px 1px rgba(255, 255, 255, 0.75); }
            50% { box-shadow: 0 0 10px 4px rgba(255, 255, 255, 0.95); } 
            100% { box-shadow: 0 0 3px 1px rgba(255, 255, 255, 0.75); }
        }
        .intellect-action img { animation: intellect-pulse 1s ease-in-out; }
    </style>
</head>
<body>
    <!-- Title will be set by JS -->
    <h1>Арена Гладиаторов</h1> 
    <div id="player-gold-display" style="text-align: center; font-size: 1.7em; margin-bottom: 15px; color: var(--warning-color); font-weight: bold; font-family: var(--font-title);">Золото: 10000 💰</div>
    
    <div class="game-controls">
        <button id="start-button">Начать Первую Битву!</button>
        <button id="restart-round-button" style="display: none;">Новый Раунд (Вручную)</button>
    </div>


    <div id="round-info-overlay">
        <h2>Вооружение Бойцов</h2>
        <ul id="weapon-info-list"></ul>
        <button id="place-bet-button">Сделать Ставку!</button>
    </div>

    <div id="betting-modal">
        <h2>Сделать Ставку на Бойца</h2>
        <p>Ваше золото: <span id="betting-modal-gold">10000</span> 💰</p>
        <p style="font-size:0.9em; color: #ccc;">Каждый раунд вы получаете 100 💰 (бонус)</p>
        <div style="margin: 15px 0;">
            <label for="bet-fighter-select">Выберите бойца:</label>
            <select id="bet-fighter-select"></select>
        </div>
        <div style="margin-bottom: 15px;">
            <label for="bet-amount-input">Сумма ставки:</label>
            <input type="number" id="bet-amount-input" min="1" style="width: 100px;">
        </div>
        <div id="betting-payouts">
            <p><strong>Выплаты:</strong></p>
            <p>1-е место: Ставка x10</p>
            <p>2-е место: Ставка x5</p>
            <p>3-е место: Ставка x3</p>
        </div>
        <div>
            <button id="confirm-bet-button">Поставить!</button>
            <button id="skip-bet-button">Продолжить без ставки</button>
        </div>
        <p id="bet-error-message"></p>
    </div>

     <div id="game-over-overlay">
        <h1>ВЫ СТАЛИ БОГОМ!</h1>
        <p>ПОЗДРАВЛЯЕМ, КОНЕЦ ИГРЫ!</p>
    </div>

    <div class="container">
        <div class="scoreboard">
            <h2>Таблица Лидеров</h2>
            <ul id="scoreboard-list"></ul>
            <button id="buy-land-button">ПОТРАТИТЬ 10,000,000 💰 И ПОБЕДИТЬ!</button>
        </div>

        <div class="main-content">
            <div class="arena-container">
                <div class="arena" id="arena"></div>
                <div class="battle-log" id="battle-log">
                    <p>Добро пожаловать! Нажмите кнопку выше, чтобы начать побоище.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const startButtonEl = document.getElementById('start-button');
        const restartRoundButtonEl = document.getElementById('restart-round-button'); 
        const playerGoldDisplayEl = document.getElementById('player-gold-display');
        const roundInfoOverlayEl = document.getElementById('round-info-overlay');
        const weaponInfoListEl = document.getElementById('weapon-info-list');
        const placeBetButtonEl = document.getElementById('place-bet-button');
        const bettingModalEl = document.getElementById('betting-modal');
        const bettingModalGoldEl = document.getElementById('betting-modal-gold');
        const betFighterSelectEl = document.getElementById('bet-fighter-select');
        const betAmountInputEl = document.getElementById('bet-amount-input');
        const confirmBetButtonEl = document.getElementById('confirm-bet-button');
        const skipBetButtonEl = document.getElementById('skip-bet-button');
        const betErrorMessageEl = document.getElementById('bet-error-message');
        const gameOverOverlayEl = document.getElementById('game-over-overlay');
        const scoreboardListEl = document.getElementById('scoreboard-list');
        const buyLandButtonEl = document.getElementById('buy-land-button');
        const arenaEl = document.getElementById('arena');
        const battleLogEl = document.getElementById('battle-log');

        // --- GAME CONSTANTS ---
        const INITIAL_GOLD = 10000;
        const GOLD_PER_ROUND_BONUS = 100;
        const WIN_AMOUNT_FOR_LAND = 10000000;
        const GAME_SPEED = 350; 
        const PRE_ROUND_WEAPON_DISPLAY_DURATION = 4000; 
        const NEW_ROUND_DELAY = 4000; 
        const ARENA_WIDTH = 1000;
        const ARENA_HEIGHT = 700;
        const FIGHTER_WIDTH = 70;
        const FIGHTER_HEIGHT = 100; 
        const MAX_FIGHTERS_TO_DISPLAY_INTELLECT_AWARD = 3; 
        const MODIFIER_CHANCE_PER_ROUND = 0.25;
        const BASE_HEALTH = 100;
        const ELITE_WEAPON_BONUS_CHANCE = 0.05; 
        const HEALTH_PACK_BONUS_CHANCE = 0.04; 
        const ARMOR_PACK_LIGHT_CHANCE = 0.03; 
        const ARMOR_PACK_HEAVY_CHANCE = 0.015; 
        const MAX_ARMOR_HITS_LIGHT = 2;
        const MAX_ARMOR_HITS_HEAVY = 3;
        const MAX_ARENA_BONUSES = 4; 
        const BONUS_PICKUP_RADIUS = 45; 
        const PROJECTILE_SPEED = 18; 
        const EXP_TO_LEVEL_UP_BASE = 100;
        const EXP_TO_LEVEL_UP_FACTOR = 1.5;
        const MAX_INTELLECT_LEVEL = 10;
        const STALL_TIMEOUT = 10000; 

        const INTELLECT_SYMBOLS = {
            tactical: '🎯', defense: '🛡️', resource: '🛠️', spatial: '🗺️'
        };
        const EXPERIENCE_REWARDS = {
            kill: { tactical: 25, spatial: 10 }, 
            kill_major_boost: { tactical: 40, spatial: 15 }, 
            assist: { tactical: 10 },
            damage_dealt_ratio: { tactical: 30 }, 
            evade_attack: { defense: 15, spatial: 5 },
            block_attack: { defense: 20 }, 
            pickup_bonus: { resource: 25, spatial: 5 },
            use_environment: { spatial: 20, resource: 5 }, 
            survive_round_tick: { defense: 1, tactical: 0.5 }, 
            win_round: { tactical: 60, defense: 40, resource: 25, spatial: 25 }, 
            place_2nd: { tactical: 35, defense: 20, resource: 15, spatial: 15 }, 
            place_3rd: { tactical: 20, defense: 15, resource: 10, spatial: 10 }, 
            target_priority_success: { tactical: 10 }, 
            defeat_dangerous_enemy: { tactical: 30 }, 
            successful_retreat: { defense: 15, spatial: 10 },
            aoe_hit_multiple: { tactical: 5 }, 
            participation: { tactical: 3, defense: 3, resource: 2, spatial: 2 }, 
        };

        const WEAPONS = [ /* Weapon list remains the same as previous correct version */
            // Original 7
            { name: "Ржавый Меч", emoji: "⚔️", type: "melee", minDamage: 8, maxDamage: 12, range: 85, critChance: 0.05, speed: 1, effects: [] },
            { name: "Дубина", emoji: "🏏", type: "melee", minDamage: 10, maxDamage: 15, range: 80, critChance: 0.02, speed: 0.9, effects: [{ type: 'stun', chance: 0.1, duration: 2 }] },
            { name: "Короткий Лук", emoji: "🏹", type: "ranged", minDamage: 7, maxDamage: 10, range: 420, critChance: 0.08, speed: 1.1, projectile: "→", effects: [] },
            { name: "Метательные Ножи", emoji: "🔪", type: "ranged", minDamage: 5, maxDamage: 8, range: 320, critChance: 0.1, speed: 1.2, projectile: "∗", effects: [{ type: 'poison', chance: 0.15, dps: 2, duration: 3 }] },
            { name: "Боевой Топор", emoji: "🪓", type: "melee", minDamage: 12, maxDamage: 18, range: 95, critChance: 0.1, speed: 0.8, effects: [] },
            { name: "Магический Посох", emoji: "🪄", type: "ranged", minDamage: 10, maxDamage: 14, range: 470, critChance: 0.05, speed: 1, projectile: "✨", effects: [{ type: 'slow', chance: 0.2, factor: 0.5, duration: 2 }] },
            { name: "Цеп", emoji: "⛓️", type: "melee", minDamage: 9, maxDamage: 13, range: 125, critChance: 0.07, speed: 0.95, effects: [{ type: 'aoe_melee', radius: 55, selfImmune: true }] },
            
            // Expanded list (total 53+)
            { name: "Тяжелый Молот", emoji: "🔨", type: "melee", minDamage: 13, maxDamage: 20, range: 90, critChance: 0.03, speed: 0.75, effects: [{ type: 'stun', chance: 0.12, duration: 1 }] },
            { name: "Острый Кинжал", emoji: "🗡️", type: "melee", minDamage: 6, maxDamage: 10, range: 75, critChance: 0.12, speed: 1.15, effects: [{ type: 'poison', chance: 0.1, dps: 1, duration: 3 }] },
            { name: "Длинный Лук", emoji: "⬆️🏹", type: "ranged", minDamage: 9, maxDamage: 14, range: 480, critChance: 0.07, speed: 1.0, projectile: "➢", effects: [] },
            { name: "Легкий Арбалет", emoji: "🎯", type: "ranged", minDamage: 10, maxDamage: 16, range: 450, critChance: 0.09, speed: 0.9, projectile: "⇒", effects: [] },
            { name: "Боевой Посох", emoji: "🌿", type: "melee", minDamage: 9, maxDamage: 14, range: 100, critChance: 0.06, speed: 0.9, effects: [] },
            { name: "Зазубренная Секира", emoji: "🪓🩸", type: "melee", minDamage: 14, maxDamage: 22, range: 92, critChance: 0.08, speed: 0.78, effects: [{ type: 'burn', chance: 0.05, dps: 2, duration: 2 }] }, // 'burn' for bleeding
            { name: "Метательный Молот", emoji: "🔨💨", type: "ranged", minDamage: 11, maxDamage: 17, range: 250, critChance: 0.04, speed: 0.85, projectile: "ธ", effects: [{ type: 'stun', chance: 0.08, duration: 1 }] },
            { name: "Отравленные Дротики", emoji: "🎯💧", type: "ranged", minDamage: 4, maxDamage: 7, range: 380, critChance: 0.05, speed: 1.25, projectile: "↦", effects: [{ type: 'poison', chance: 0.25, dps: 3, duration: 3 }] },
            { name: "Копье", emoji: "🔱", type: "melee", minDamage: 10, maxDamage: 16, range: 130, critChance: 0.07, speed: 0.95, effects: [] },
            { name: "Праща с Камнями", emoji: "🌀", type: "ranged", minDamage: 6, maxDamage: 11, range: 350, critChance: 0.03, speed: 1.05, projectile: "●", effects: [] },
            { name: "Стальной Кастет", emoji: "👊", type: "melee", minDamage: 7, maxDamage: 11, range: 70, critChance: 0.09, speed: 1.1, effects: [] },
            { name: "Огненный Жезл", emoji: "🔥🦯", type: "ranged", minDamage: 9, maxDamage: 15, range: 400, critChance: 0.06, speed: 0.95, projectile: "☄️", effects: [{ type: 'burn', chance: 0.2, dps: 3, duration: 2 }] },
            { name: "Ледяной Клинок", emoji: "❄️🗡️", type: "melee", minDamage: 10, maxDamage: 15, range: 88, critChance: 0.05, speed: 0.98, effects: [{ type: 'slow', chance: 0.15, factor: 0.4, duration: 2 }] },
            { name: "Парные Кинжалы", emoji: "🔪🔪", type: "melee", minDamage: 7, maxDamage: 10, range: 78, critChance: 0.15, speed: 1.2, effects: [] },
            { name: "Утренняя Звезда", emoji: "🌟🔨", type: "melee", minDamage: 12, maxDamage: 19, range: 95, critChance: 0.04, speed: 0.82, effects: [{ type: 'stun', chance: 0.1, duration: 1 }] },
            { name: "Сюрикены", emoji: "⭐", type: "ranged", minDamage: 3, maxDamage: 6, range: 300, critChance: 0.18, speed: 1.3, projectile: "✴", effects: [] },
            { name: "Двуручный Меч", emoji: "⬆️⚔️", type: "melee", minDamage: 15, maxDamage: 25, range: 110, critChance: 0.07, speed: 0.7, effects: [] },
            { name: "Электрический Хлыст", emoji: "⚡〰️", type: "melee", minDamage: 8, maxDamage: 13, range: 140, critChance: 0.08, speed: 1.0, effects: [{ type: 'slow', chance: 0.1, factor: 0.3, duration: 2 }, { type: 'stun', chance: 0.05, duration: 1 }] },
            { name: "Взрывной Болт (Арбалет)", emoji: "💥🎯", type: "ranged", minDamage: 12, maxDamage: 20, range: 430, critChance: 0.05, speed: 0.8, projectile: "💣", effects: [{ type: 'aoe_ranged', radius: 40, selfImmune: false, subDamageFactor: 0.5 }] },
            { name: "Святой Молот", emoji: "🔨✨", type: "melee", minDamage: 11, maxDamage: 17, range: 93, critChance: 0.06, speed: 0.88, effects: [] }, 
            { name: "Темный Клинок", emoji: "🌑🗡️", type: "melee", minDamage: 10, maxDamage: 16, range: 90, critChance: 0.09, speed: 0.92, effects: [{ type: 'poison', chance: 0.1, dps: 2, duration: 4 }] },
            { name: "Проклятый Лук", emoji: "💀🏹", type: "ranged", minDamage: 8, maxDamage: 13, range: 460, critChance: 0.11, speed: 1.02, projectile: "☠", effects: [{ type: 'root', chance: 0.08, duration: 1 }] },
            { name: "Каменный Молот", emoji: "🗿🔨", type: "melee", minDamage: 14,maxDamage: 23, range: 85, critChance: 0.02, speed: 0.65, effects: [{type:"stun", chance: 0.15, duration: 2}]},
            { name: "Костяной Лук", emoji: "🦴🏹", type: "ranged", minDamage: 7, maxDamage: 11, range: 410, critChance: 0.07, speed: 1.0, projectile: "🦴", effects: []},
            { name: "Изогнутая Сабля", emoji: "🌙🗡️", type: "melee", minDamage: 9, maxDamage: 15, range: 90, critChance: 0.08, speed: 1.05, effects: []},
            { name: "Малый Щит (для удара)", emoji: "🛡️👊", type: "melee", minDamage: 5, maxDamage: 9, range: 70, critChance: 0.03, speed: 0.9, effects: [{type:"stun", chance: 0.08, duration: 1}]},
            { name: "Отравленный Дыхательный Трубка", emoji: "🌬️💧", type: "ranged", minDamage: 2, maxDamage: 4, range: 280, critChance: 0.02, speed: 1.1, projectile: "💦", effects: [{type:"poison", chance: 0.3, dps: 4, duration: 3}]},
            { name: "Цепной Моргенштерн", emoji: "🔗🌟", type: "melee", minDamage: 10, maxDamage: 18, range: 115, critChance: 0.05, speed: 0.85, effects: [{ type: 'aoe_melee', radius: 50, selfImmune: true }]},
            { name: "Тяжелый Арбалет", emoji: "🏋️🎯", type: "ranged", minDamage: 13, maxDamage: 20, range: 500, critChance: 0.1, speed: 0.75, projectile: "BOLT", effects: []},
            { name: "Боевые Когти", emoji: "爪", type: "melee", minDamage: 8, maxDamage: 12, range: 72, critChance: 0.13, speed: 1.18, effects: []},
            { name: "Кристальный Посох", emoji: "💎🪄", type: "ranged", minDamage: 11, maxDamage: 17, range: 480, critChance: 0.07, speed: 0.93, projectile: "💠", effects: [{type:"slow", chance: 0.18, factor: 0.35, duration: 2}]},
            { name: "Железная Палица", emoji: "🔩🏏", type: "melee", minDamage: 12, maxDamage: 19, range: 82, critChance: 0.04, speed: 0.8, effects: [{type:"stun", chance: 0.11, duration: 1}]},
            { name: "Охотничье Копье", emoji: "🌿🔱", type: "ranged", minDamage: 9, maxDamage: 14, range: 320, critChance: 0.09, speed: 0.97, projectile: "↑", effects: []}, 
            { name: "Деревянный Щит (атака)", emoji: "🪵🛡️", type: "melee", minDamage: 4, maxDamage: 7, range: 65, critChance: 0.01, speed: 0.85, effects: []},
            { name: "Метательные Топоры", emoji: "🪓💨", type: "ranged", minDamage: 8, maxDamage: 14, range: 290, critChance: 0.08, speed: 0.9, projectile: "AXE", effects: []},
            { name: "Ядовитый Кнут", emoji: "🐍〰️", type: "melee", minDamage: 7, maxDamage: 11, range: 135, critChance: 0.06, speed: 1.05, effects: [{type: "poison", chance: 0.25, dps: 2, duration: 4}]},
            { name: "Священная Книга (удар)", emoji: "📖💥", type: "melee", minDamage: 6, maxDamage: 10, range: 75, critChance: 0.02, speed: 0.9, effects: [{type: "stun", chance: 0.1, duration: 1}, {type: "slow", chance: 0.1, factor: 0.2, duration: 2}]},
            { name: "Чакрам", emoji: "💿", type: "ranged", minDamage: 9, maxDamage: 13, range: 360, critChance: 0.12, speed: 1.1, projectile: "🔄", effects: []}, 
            { name: "Кистень", emoji: "💣🔗", type: "melee", minDamage: 11, maxDamage: 17, range: 100, critChance: 0.05, speed: 0.88, effects: [{type: "stun", chance: 0.12, duration: 1}]},
            { name: "Посох Призывателя (слабый удар)", emoji: "💀🪄", type: "melee", minDamage: 5, maxDamage: 8, range: 80, critChance: 0.01, speed: 0.95, effects: []}, 
            { name: "Трезубец", emoji: "🔱🌊", type: "melee", minDamage: 12, maxDamage: 19, range: 120, critChance: 0.08, speed: 0.92, effects: []}, 
            { name: "Отравленные Шипы (ловушка)", emoji: "🌵", type: "melee", minDamage: 4, maxDamage: 7, range: 70, critChance: 0.03, speed: 1.0, effects: [{type:"poison", chance: 0.4, dps: 3, duration: 2}]}, 
            { name: "Бумеранг", emoji: "↩️", type: "ranged", minDamage: 7, maxDamage: 12, range: 330, critChance: 0.07, speed: 1.0, projectile: "🔄", effects: []}, 
            { name: "Болас", emoji: "➰", type: "ranged", minDamage: 3, maxDamage: 6, range: 280, critChance: 0.02, speed: 0.9, projectile: "➿", effects: [{type: "root", chance: 0.25, duration: 2}]},
            { name: "Тяжелая Цепь", emoji: "🔗🔗", type: "melee", minDamage: 10, maxDamage: 16, range: 110, critChance: 0.04, speed: 0.8, effects: [{type:"slow", chance: 0.15, factor: 0.4, duration: 1}]},
            { name: "Осадный Лук", emoji: "🏹🏰", type: "ranged", minDamage: 14, maxDamage: 22, range: 550, critChance: 0.05, speed: 0.65, projectile: "❱❱❱", effects: []},
            { name: "Ритуальный Кинжал", emoji: "🔪🩸", type: "melee", minDamage: 8, maxDamage: 13, range: 77, critChance: 0.1, speed: 1.1, effects: [{type: "lifesteal", chance: 0.1, percent: 0.15}]}, 
            { name: "Ледяные Осколки (снаряд)", emoji: "❄️✨", type: "ranged", minDamage: 6, maxDamage: 10, range: 400, critChance: 0.08, speed: 1.15, projectile: "❄", effects: [{type:"slow", chance: 0.2, factor: 0.3, duration: 2}]},
            { name: "Гарпун", emoji: "⚓", type: "ranged", minDamage: 10, maxDamage: 15, range: 300, critChance: 0.06, speed: 0.8, projectile: "⚓", effects: [{type: "pull", chance: 0.15, distance: 50}]}, 
            { name: "Книга Заклинаний (огненный шар)", emoji: "📖🔥", type: "ranged", minDamage: 9, maxDamage: 16, range: 440, critChance: 0.07, speed: 0.95, projectile: "🔥", effects: [{type: "burn", chance: 0.18, dps: 3, duration: 2}]},
            { name: "Молот Земли", emoji: "🔨🌍", type: "melee", minDamage: 13, maxDamage: 21, range: 92, critChance: 0.03, speed: 0.7, effects: [{type: "aoe_melee", radius: 60, selfImmune: true, subDamageFactor: 0.4}]},
            { name: "Ветряной Клинок", emoji: "🌬️🗡️", type: "melee", minDamage: 9, maxDamage: 14, range: 95, critChance: 0.09, speed: 1.12, effects: [{type: "push", chance: 0.1, distance: 40}]}, 
            { name: "Метательные Иглы", emoji: "針", type: "ranged", minDamage: 2, maxDamage: 5, range: 310, critChance: 0.15, speed: 1.35, projectile: "|", effects: [{type: "poison", chance: 0.1, dps: 1, duration: 5}]},
            { name: "Энергетический Меч", emoji: "💡⚔️", type: "melee", minDamage: 10, maxDamage: 17, range: 90, critChance: 0.07, speed: 1.0, effects: []}, 
            { name: "Звуковой Удар (посох)", emoji: "🔊🪄", type: "ranged", minDamage: 8, maxDamage: 12, range: 380, critChance: 0.04, speed: 0.9, projectile: "🎶", effects: [{type: "stun", chance: 0.08, duration: 1}]},
        ];

        const ELITE_WEAPONS = [ /* Weapon list remains the same as previous correct version */
            // Original 3
            { name: "Огненный Клинок", emoji: "🔥⚔️", type: "melee", minDamage: 20, maxDamage: 30, range: 110, critChance: 0.15, speed: 1, effects: [{ type: 'burn', chance: 0.5, dps: 5, duration: 3 }] },
            { name: "Громовой Молот", emoji: "🔨⚡", type: "melee", minDamage: 25, maxDamage: 35, range: 100, critChance: 0.1, speed: 0.7, effects: [{ type: 'stun', chance: 0.3, duration: 3 }, { type: 'aoe_melee', radius: 75, selfImmune: true }] },
            { name: "Ледяной Лук", emoji: "❄️🏹", type: "ranged", minDamage: 18, maxDamage: 25, range: 520, critChance: 0.12, speed: 1.1, projectile: "❄️", effects: [{ type: 'slow', chance: 0.4, factor: 0.3, duration: 3 }, { type: 'root', chance: 0.1, duration: 2 }] },
            
            // Expanded to 15+
            { name: "Клинок Бури", emoji: "🌪️⚔️", type: "melee", minDamage: 22, maxDamage: 32, range: 115, critChance: 0.18, speed: 1.05, effects: [{ type: 'aoe_melee', radius: 65, selfImmune: true }, { type: 'slow', chance: 0.25, factor: 0.3, duration: 2 }] },
            { name: "Посох Архимага", emoji: "🌟🪄", type: "ranged", minDamage: 20, maxDamage: 28, range: 550, critChance: 0.1, speed: 1, projectile: "🌠", effects: [{ type: 'burn', chance: 0.3, dps: 6, duration: 3 }, { type: 'stun', chance: 0.15, duration: 1 }] },
            { name: "Коса Жнеца", emoji: "💀🔪", type: "melee", minDamage: 28, maxDamage: 40, range: 120, critChance: 0.2, speed: 0.8, effects: [{ type: 'poison', chance: 0.4, dps: 7, duration: 4 }, {type: 'lifesteal', chance: 0.2, percent: 0.25}] },
            { name: "Арбалет Истребителя", emoji: "☠️🎯", type: "ranged", minDamage: 25, maxDamage: 35, range: 600, critChance: 0.25, speed: 0.9, projectile: "☣️", effects: [{ type: 'root', chance: 0.2, duration: 2 }, {type: 'armor_pierce', chance: 0.3}] },
            { name: "Молот Титана", emoji: "🌋🔨", type: "melee", minDamage: 30, maxDamage: 45, range: 95, critChance: 0.08, speed: 0.6, effects: [{ type: 'stun', chance: 0.4, duration: 3 }, { type: 'aoe_melee', radius: 80, selfImmune: true }, {type: 'burn', chance: 0.2, dps: 4, duration: 2}] },
            { name: "Лук Звездного Охотника", emoji: "🌌🏹", type: "ranged", minDamage: 20, maxDamage: 30, range: 580, critChance: 0.15, speed: 1.15, projectile: "⭐", effects: [{ type: 'slow', chance: 0.3, factor: 0.25, duration: 3 }, { type: 'burn', chance: 0.2, dps: 5, duration: 2 }] },
            { name: "Парные Клинки Хаоса", emoji: "🔥⛓️", type: "melee", minDamage: 18, maxDamage: 26, range: 125, critChance: 0.16, speed: 1.2, effects: [{ type: 'aoe_melee', radius: 70, selfImmune: true }, { type: 'burn', chance: 0.35, dps: 4, duration: 3 }] },
            { name: "Скипетр Забвения", emoji: "🌀🔱", type: "ranged", minDamage: 24, maxDamage: 33, range: 530, critChance: 0.11, speed: 0.95, projectile: "🔮", effects: [{ type: 'poison', chance: 0.3, dps: 6, duration: 4 }, { type: 'slow', chance: 0.2, factor: 0.4, duration: 3 }] },
            { name: "Копье Драконоборца", emoji: "🐉🔱", type: "melee", minDamage: 26, maxDamage: 38, range: 140, critChance: 0.13, speed: 0.9, effects: [{ type: 'burn', chance: 0.4, dps: 5, duration: 3}] },
            { name: "Рукавицы Титана", emoji: "👊💥", type: "melee", minDamage: 20, maxDamage: 30, range: 80, critChance: 0.1, speed: 1.0, effects: [{type: 'stun', chance: 0.25, duration: 2}]},
            { name: "Лук Шепота Ветра", emoji: "🍃🏹", type: "ranged", minDamage: 19, maxDamage: 27, range: 620, critChance: 0.14, speed: 1.2, projectile: "~", effects: [{type: 'poison', chance: 0.2, dps: 4, duration: 3}, {type: 'slow', chance: 0.2, factor: 0.2, duration: 3}]},
            { name: "Секира Варвара", emoji: "🪓😡", type: "melee", minDamage: 27, maxDamage: 39, range: 105, critChance: 0.12, speed: 0.75, effects: [{type: 'aoe_melee', radius: 60, selfImmune: true}]},
            { name: "Посох Землетрясения", emoji: "🌍🪄", type: "ranged", minDamage: 22, maxDamage: 31, range: 500, critChance: 0.09, speed: 0.85, projectile: "🧱", effects: [{type: 'stun', chance: 0.2, duration: 2}, {type: 'root', chance: 0.15, duration: 2}, {type: 'aoe_ranged', radius: 50, selfImmune: false, subDamageFactor: 0.6}]},
            { name: "Меч Солнечной Ярости", emoji: "☀️⚔️", type: "melee", minDamage: 24, maxDamage: 34, range: 112, critChance: 0.17, speed: 1.02, effects: [{type: 'burn', chance: 0.5, dps: 6, duration: 3}]}
        ];


        const STATUS_EFFECT_DEFINITIONS = {
            poison: { dps: 0, duration: 0, color: 'var(--poison-color)' },
            stun: { duration: 0, color: 'var(--warning-color)' },
            root: { duration: 0, color: 'var(--root-color)' },
            slow: { factor: 1, duration: 0, color: 'var(--slow-color)' },
            enrage: { damageMultiplier: 1, speedMultiplier: 1, duration: 0, color: 'var(--enrage-color)' },
            burn: { dps: 0, duration: 0, color: 'var(--danger-color)'},
            lifesteal: { percent: 0 }, 
            pull: { distance: 0 },    
            push: { distance: 0 },    
            armor_pierce: {}           
        };
        
        const roundModifiers = [
            { 
                name: "Ярость Берсерка", 
                description: "Все бойцы наносят на 25% больше урона, но получают на 15% больше урона.",
                apply: (fighter) => { 
                    fighter.damageOutputMultiplier = (fighter.damageOutputMultiplier || 1) * 1.25;
                    fighter.damageTakenMultiplier = (fighter.damageTakenMultiplier || 1) * 1.15;
                },
                remove: (fighter) => {
                    if (fighter && fighter.damageOutputMultiplier) fighter.damageOutputMultiplier /= 1.25; // Added fighter check
                    if (fighter && fighter.damageTakenMultiplier) fighter.damageTakenMultiplier /= 1.15; // Added fighter check
                }
            },
            { 
                name: "Быстрые Ноги", 
                description: "Скорость передвижения всех бойцов увеличена на 30%.",
                apply: (fighter) => { fighter.speed = (fighter.speed || fighter.baseSpeed) * 1.3; },
                remove: (fighter) => { if (fighter && fighter.speed) fighter.speed /= 1.3; } // Added fighter check
            },
            { 
                name: "Густой Туман", 
                description: "Дальность атаки всех дальнобойных оружий снижена на 30%.",
                apply: (fighter) => { 
                    if (fighter.weapon && fighter.weapon.type === 'ranged') fighter.weapon.currentRange = (fighter.weapon.currentRange || fighter.weapon.range) * 0.7; 
                },
                remove: (fighter) => {
                     // Added checks for fighter and fighter.weapon
                     if (fighter && fighter.weapon && fighter.weapon.type === 'ranged' && fighter.weapon.currentRange) {
                         fighter.weapon.currentRange /= 0.7; 
                     }
                }
            },
            {
                name: "Целебный Воздух",
                description: "Все бойцы медленно восстанавливают 1 ОЗ за игровой тик.",
                applyTick: (fighter) => {
                    if (fighter.health < fighter.maxHealth) {
                        fighter.health = Math.min(fighter.maxHealth, fighter.health + 1);
                    }
                }
                // No remove needed
            },
            {
                name: "Хрупкая Броня",
                description: "Вся подобранная броня имеет на 1 заряд меньше.",
                apply: (fighter) => { /* Applied at armor pickup */ },
                // No remove needed
            }
        ];

        const fightersInitialData = [ // Updated image paths to relative
             { id: "fighter1", name: "Андрей Д", image: "images/1.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'closest', caution: 0.01, aggression: 0.98, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter2", name: "Андрей П", image: "images/2.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'weakest', caution: 0.03, aggression: 0.95, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter3", name: "Валера", image: "images/Валера.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'random', caution: 0.005, aggression: 0.99, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter4", name: "Вова", image: "images/Вова.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'closest', caution: 0.04, aggression: 0.92, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter5", name: "Глеб", image: "images/Глеб.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'highest_threat', caution: 0.02, aggression: 0.96, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter6", name: "Кирилл", image: "images/Кирилл.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'random', caution: 0.01, aggression: 0.97, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter7", name: "Олег", image: "images/Олег.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'weakest', caution: 0.05, aggression: 0.90, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter8", name: "Панк", image: "images/Панк.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'closest', caution: 0.001, aggression: 1.0, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter9", name: "Санёк Гер", image: "images/Санек Гер.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'highest_threat', caution: 0.02, aggression: 0.94, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter10", name: "Санёк Гол", image: "images/Санек.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'random', caution: 0.015, aggression: 0.95, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}},
             { id: "fighter11", name: "Тимоха", image: "images/Тимоха.jpg", wins: 0, participating: true, combatStats: { preferredTargetType: 'weakest', caution: 0.06, aggression: 0.88, learnedGrudges: {}, intellect: { tactical: 1, defense: 1, resource: 1, spatial: 1 }, experience: { tactical: 0, defense: 0, resource: 0, spatial: 0 }, learning: { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] }}}
        ];

        // --- GAME STATE VARIABLES ---
        let playerGold = INITIAL_GOLD;
        let roundCounter = 0;
        let gameLoopInterval = null;
        let preRoundTimeoutId = null;
        let currentFighters = [];
        let arenaBonuses = [];
        let duelContenders = null;
        let activeRoundModifier = null;
        let intelliActionLog = {}; 
        let currentBet = { fighterId: null, amount: 0, placed: false };
        let isBettingPaused = false;
        let defeatedFightersOrder = []; 
        let isGameOver = false;
        let firstRoundStarted = false;
        let roundInProgress = false;
        createFighterInstance.commonWeaponThisRound = null; 
        let lastDamageTimestamp = Date.now(); 


        // --- UTILITY FUNCTIONS ---
        function logMessage(message, className = "") {
            const p = document.createElement('p');
            p.innerHTML = message; 
            if (className) p.classList.add(className);
            battleLogEl.appendChild(p);
            battleLogEl.scrollTop = battleLogEl.scrollHeight;
        }

        function updatePlayerGoldDisplay() {
            playerGoldDisplayEl.innerHTML = `Золото: ${playerGold.toLocaleString()} 💰`;
            bettingModalGoldEl.textContent = playerGold.toLocaleString();
            if (buyLandButtonEl) {
                buyLandButtonEl.disabled = playerGold < WIN_AMOUNT_FOR_LAND || isGameOver;
                buyLandButtonEl.classList.toggle('disabled', playerGold < WIN_AMOUNT_FOR_LAND || isGameOver);
            }
        }
        
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getDistance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTotalIntellect(fighter) {
            if (!fighter || !fighter.combatStats || !fighter.combatStats.intellect) return 0;
            const { tactical, defense, resource, spatial } = fighter.combatStats.intellect;
            return tactical + defense + resource + spatial;
        }

        function getExpToLevelUp(currentLevel) {
            return Math.floor(EXP_TO_LEVEL_UP_BASE * Math.pow(EXP_TO_LEVEL_UP_FACTOR, currentLevel -1));
        }

        // --- SCOREBOARD AND UI ---
        function updateScoreboard() {
            if (!scoreboardListEl) return;
            scoreboardListEl.innerHTML = '';
            const sortedFighters = [...fightersInitialData].sort((a, b) => b.wins - a.wins);
            
            sortedFighters.forEach(fighterData => {
                const li = document.createElement('li');
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.classList.add('fighter-checkbox');
                checkbox.checked = fighterData.participating;
                checkbox.dataset.fighterId = fighterData.id;
                checkbox.disabled = isGameOver || roundInProgress;
                checkbox.addEventListener('change', (event) => {
                    const fId = event.target.dataset.fighterId;
                    const fData = fightersInitialData.find(f => f.id === fId);
                    if (fData) {
                        fData.participating = event.target.checked;
                        updateScoreboard(); 
                    }
                });
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = fighterData.name;
                nameSpan.style.marginRight = 'auto'; 
                
                const intellectSpan = document.createElement('span');
                intellectSpan.classList.add('fighter-intellect');
                
                if (fighterData.combatStats && fighterData.combatStats.intellect) {
                    const { tactical, defense, resource, spatial } = fighterData.combatStats.intellect;
                    if (tactical > 1) intellectSpan.innerHTML += `<span class="int-tactical">${INTELLECT_SYMBOLS.tactical}${tactical}</span>`;
                    if (defense > 1) intellectSpan.innerHTML += `<span class="int-defense">${INTELLECT_SYMBOLS.defense}${defense}</span>`;
                    if (resource > 1) intellectSpan.innerHTML += `<span class="int-resource">${INTELLECT_SYMBOLS.resource}${resource}</span>`;
                    if (spatial > 1) intellectSpan.innerHTML += `<span class="int-spatial">${INTELLECT_SYMBOLS.spatial}${spatial}</span>`;
                }
                
                const winsSpan = document.createElement('span');
                winsSpan.classList.add('wins');
                winsSpan.textContent = '🏆'.repeat(fighterData.wins);
                
                li.appendChild(checkbox);
                li.appendChild(nameSpan);
                li.appendChild(intellectSpan);
                li.appendChild(winsSpan);
                scoreboardListEl.appendChild(li);
            });
        }

        // --- FIGHTER CREATION AND MANAGEMENT ---
        function createFighterInstance(data) {
            const baseData = JSON.parse(JSON.stringify(data)); 
            let weapon;

            if (roundCounter > 0 && roundCounter % 5 === 0) { 
                if (!createFighterInstance.commonWeaponThisRound) {
                    createFighterInstance.commonWeaponThisRound = { ...WEAPONS[getRandomInt(0, WEAPONS.length - 1)] };
                }
                weapon = { ...createFighterInstance.commonWeaponThisRound };
            } else {
                 weapon = { ...WEAPONS[getRandomInt(0, WEAPONS.length - 1)] };
            }
            weapon.currentRange = weapon.range; 

            if (!baseData.combatStats.intellect) {
                baseData.combatStats.intellect = { tactical: 1, defense: 1, resource: 1, spatial: 1 };
            }
            if (!baseData.combatStats.experience) {
                baseData.combatStats.experience = { tactical: 0, defense: 0, resource: 0, spatial: 0 };
            }
             if (!baseData.combatStats.learning) {
                baseData.combatStats.learning = { weaponEffectiveness: {}, targetPriorities: {}, dangerousEnemies: {}, optimalDistances: {}, successfulPatterns: [] };
            }

            const fighter = {
                ...baseData,
                health: BASE_HEALTH,
                maxHealth: BASE_HEALTH,
                baseSpeed: getRandomInt(15, 25), 
                speed: 0, 
                weapon: weapon,
                x: getRandomInt(FIGHTER_WIDTH / 2, ARENA_WIDTH - FIGHTER_WIDTH / 2),
                y: getRandomInt(FIGHTER_HEIGHT / 2, ARENA_HEIGHT - FIGHTER_HEIGHT / 2),
                alive: true,
                element: null,
                target: null,
                actionCooldown: 0,
                statusEffects: {}, 
                damageOutputMultiplier: 1,
                damageTakenMultiplier: 1,
                evasionChance: 0.05 + (baseData.combatStats.intellect.defense * 0.005), 
                currentAction: null, 
                actionProgress: 0, 
                lastDamagedBy: null, 
                damageDealtThisRound: 0,
                killsThisRound: 0,
                bonusesCollectedThisRound: 0,
                ticksSurvivedThisRound: 0,
                armorHits: 0, 
                maxArmorHits: 0, 
                hasArmor: false, 
                initialExpThisRound: JSON.parse(JSON.stringify(baseData.combatStats.experience)), 
            };
            fighter.speed = fighter.baseSpeed; 
            return fighter;
        }

        function createFighterElement(fighter) {
            const el = document.createElement('div');
            el.classList.add('fighter-on-arena', 'breathing');
            el.id = fighter.id;
            el.style.left = `${fighter.x - FIGHTER_WIDTH / 2}px`;
            el.style.top = `${fighter.y - FIGHTER_HEIGHT / 2}px`;

            const healthBarContainer = document.createElement('div');
            healthBarContainer.classList.add('health-bar-container');
            const healthBar = document.createElement('div');
            healthBar.classList.add('health-bar');
            healthBarContainer.appendChild(healthBar);
            
            const armorBarContainer = document.createElement('div'); 
            armorBarContainer.classList.add('armor-bar-container');
            const armorBar = document.createElement('div');
            armorBar.classList.add('armor-bar');
            armorBarContainer.appendChild(armorBar);


            const img = document.createElement('img');
            img.src = fighter.image;
            img.alt = fighter.name;
            img.onerror = () => { img.src = 'images/default.png'; }; 

            const nameDisplay = document.createElement('span');
            nameDisplay.classList.add('fighter-name-display');
            nameDisplay.textContent = fighter.name;

            const weaponEmoji = document.createElement('span');
            weaponEmoji.classList.add('weapon-emoji');
            weaponEmoji.textContent = fighter.weapon.emoji;
            
            const intActionHint = document.createElement('div');
            intActionHint.classList.add('int-action-hint');
            intActionHint.textContent = "..."; 
            
            el.appendChild(healthBarContainer);
            el.appendChild(armorBarContainer); 
            el.appendChild(img);
            el.appendChild(nameDisplay);
            el.appendChild(weaponEmoji);
            el.appendChild(intActionHint);

            arenaEl.appendChild(el);
            fighter.element = el;
            updateFighterIntellectVisuals(fighter); 
        }

        function updateFighterIntellectVisuals(fighter) { 
            if (!fighter.element) return;
            const imgEl = fighter.element.querySelector('img');
            if (!imgEl) return;

            const totalInt = getTotalIntellect(fighter);
            imgEl.classList.toggle('has-intellect', totalInt > 4 && !fighter.hasArmor); 
            imgEl.classList.toggle('int-level-high', totalInt >= 8 && !fighter.hasArmor);
        }


        function updateFighterElement(fighter) {
            if (!fighter.element || !fighter.alive) return;

            fighter.element.style.left = `${fighter.x - FIGHTER_WIDTH / 2}px`;
            fighter.element.style.top = `${fighter.y - FIGHTER_HEIGHT / 2}px`;

            const healthBar = fighter.element.querySelector('.health-bar');
            const healthPercent = (fighter.health / fighter.maxHealth) * 100;
            healthBar.style.width = `${healthPercent}%`;
            
            if (healthPercent < 30) healthBar.style.backgroundImage = 'linear-gradient(to bottom, #F44336, #D32F2F)';
            else if (healthPercent < 60) healthBar.style.backgroundImage = 'linear-gradient(to bottom, #FFC107, #FFA000)';
            else healthBar.style.backgroundImage = 'linear-gradient(to bottom, #66BB6A, #4CAF50)'; 

            healthBar.classList.toggle('poisoned', !!fighter.statusEffects.poison || !!fighter.statusEffects.burn);
            
            fighter.element.classList.toggle('has-armor', fighter.hasArmor); 
            const armorBar = fighter.element.querySelector('.armor-bar');
            if (fighter.hasArmor && fighter.maxArmorHits > 0) {
                const armorPercent = (fighter.armorHits / fighter.maxArmorHits) * 100;
                armorBar.style.width = `${armorPercent}%`;
            }


            fighter.element.classList.toggle('is-stunned', !!fighter.statusEffects.stun);
            fighter.element.classList.toggle('is-rooted', !!fighter.statusEffects.root);
            fighter.element.classList.toggle('is-slowed', !!fighter.statusEffects.slow);
            fighter.element.classList.toggle('enraged', !!fighter.statusEffects.enrage);
            updateFighterIntellectVisuals(fighter); 


            const hintEl = fighter.element.querySelector('.int-action-hint');
            if (intelliActionLog[fighter.id] && intelliActionLog[fighter.id].message) {
                hintEl.textContent = `${INTELLECT_SYMBOLS[intelliActionLog[fighter.id].type]} ${intelliActionLog[fighter.id].message}`;
                hintEl.style.color = `var(--${intelliActionLog[fighter.id].type}-int-color)`;
            } else {
                hintEl.textContent = ""; 
                hintEl.style.color = "white";
            }
        }
        
        function removeFighterElement(fighter) {
            if (fighter.element && fighter.element.parentElement) {
                fighter.element.remove();
            }
        }
        
        // --- EXPERIENCE AND INTELLECT ---
        function addExperience(fighter, eventTypeKey, baseAmountMultiplier = 1) {
            if (!fighter || !fighter.alive || !EXPERIENCE_REWARDS[eventTypeKey]) return;

            const rewardsForEvent = EXPERIENCE_REWARDS[eventTypeKey];
            let gainedAnyExp = false;

            for (const intellectType in rewardsForEvent) {
                if (fighter.combatStats.intellect[intellectType] >= MAX_INTELLECT_LEVEL) continue;
                
                const amount = rewardsForEvent[intellectType] * baseAmountMultiplier;
                if (amount === 0) continue;

                fighter.combatStats.experience[intellectType] += amount;
                gainedAnyExp = true;

                const expNeeded = getExpToLevelUp(fighter.combatStats.intellect[intellectType]);
                if (fighter.combatStats.experience[intellectType] >= expNeeded) {
                    fighter.combatStats.intellect[intellectType]++;
                    fighter.combatStats.experience[intellectType] -= expNeeded; 
                    logMessage(`🧠 <span class="log-int-levelup">${fighter.name} повысил ${intellectType} интеллект до ${fighter.combatStats.intellect[intellectType]}!</span> (<span class="log-int-${intellectType}">${INTELLECT_SYMBOLS[intellectType]}</span>)`, "log-int-levelup");
                    updateFighterIntellectVisuals(fighter); 
                    
                    for (let i = 0; i < 5; i++) {
                        const sparkle = document.createElement('div');
                        sparkle.classList.add('intellect-levelup-sparkle');
                        sparkle.style.left = `${fighter.x + getRandomInt(-15, 15) - 4}px`;
                        sparkle.style.top = `${fighter.y - FIGHTER_HEIGHT / 2 + getRandomInt(-10, 0) - 4}px`;
                        sparkle.style.animationDelay = `${i * 0.05}s`;
                        arenaEl.appendChild(sparkle);
                        setTimeout(() => {if(sparkle.parentElement) sparkle.remove()}, 600); // Added check
                    }
                }
            }
            if (gainedAnyExp) updateScoreboard(); 
        }

        function processRoundExperience() {
            const winner = currentFighters.find(f => f.alive);
            
            currentFighters.forEach(fighter => {
                if (fighter.initialExpThisRound === undefined) { 
                     fighter.initialExpThisRound = JSON.parse(JSON.stringify(fighter.combatStats.experience));
                }

                addExperience(fighter, 'participation'); 
                addExperience(fighter, 'survive_round_tick', fighter.ticksSurvivedThisRound);

                if (fighter.damageDealtThisRound > 0) {
                    addExperience(fighter, 'damage_dealt_ratio', (fighter.damageDealtThisRound / BASE_HEALTH));
                }
                
                if (winner) {
                    if (fighter.id === winner.id) {
                        addExperience(fighter, 'win_round');
                    } else if (defeatedFightersOrder.length > 0 && defeatedFightersOrder[defeatedFightersOrder.length - 1] === fighter.id) {
                        addExperience(fighter, 'place_2nd');
                    } else if (defeatedFightersOrder.length > 1 && defeatedFightersOrder[defeatedFightersOrder.length - 2] === fighter.id) {
                        addExperience(fighter, 'place_3rd');
                    }
                } else { 
                    if (defeatedFightersOrder.length > 0 && defeatedFightersOrder[defeatedFightersOrder.length - 1] === fighter.id) {
                        addExperience(fighter, 'place_2nd'); 
                    } else if (defeatedFightersOrder.length > 1 && defeatedFightersOrder[defeatedFightersOrder.length - 2] === fighter.id) {
                        addExperience(fighter, 'place_3rd');
                    }
                }
                delete fighter.initialExpThisRound;
            });
        }


        function logIntellectAction(fighter, intellectType, message) {
            intelliActionLog[fighter.id] = { type: intellectType, message: message };
            
            if(fighter.element) { 
                fighter.element.classList.add('intellect-action');
                setTimeout(() => {
                    if(fighter.element) fighter.element.classList.remove('intellect-action');
                }, 600); 
            }
        }

        // --- ARENA BONUSES ---
        function manageArenaBonuses() {
            if (arenaBonuses.length < MAX_ARENA_BONUSES) {
                const randomChance = Math.random();
                const tickRateFactor = 1000 / GAME_SPEED; 

                if (randomChance < ELITE_WEAPON_BONUS_CHANCE / tickRateFactor ) { 
                    spawnArenaBonus('elite_weapon');
                } else if (randomChance < (ELITE_WEAPON_BONUS_CHANCE + HEALTH_PACK_BONUS_CHANCE) / tickRateFactor ) {
                    spawnArenaBonus('health_pack');
                } else if (randomChance < (ELITE_WEAPON_BONUS_CHANCE + HEALTH_PACK_BONUS_CHANCE + ARMOR_PACK_LIGHT_CHANCE) / tickRateFactor ) {
                    spawnArenaBonus('armor_light');
                } else if (randomChance < (ELITE_WEAPON_BONUS_CHANCE + HEALTH_PACK_BONUS_CHANCE + ARMOR_PACK_LIGHT_CHANCE + ARMOR_PACK_HEAVY_CHANCE) / tickRateFactor ) {
                    spawnArenaBonus('armor_heavy');
                }
            }
        }

        function spawnArenaBonus(type) {
            if (arenaBonuses.length >= MAX_ARENA_BONUSES) return;

            const bonus = {
                id: `bonus-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                type: type,
                x: getRandomInt(30, ARENA_WIDTH - 30), 
                y: getRandomInt(30, ARENA_HEIGHT - 30),
                element: document.createElement('div')
            };
            bonus.element.classList.add('arena-bonus');

            if (type === 'health_pack') {
                bonus.element.classList.add('health-pack');
                bonus.element.textContent = '➕';
                bonus.element.title = "Аптечка (+50 ОЗ)";
                bonus.value = 50;
            } else if (type === 'elite_weapon') {
                bonus.element.classList.add('elite-weapon-pickup');
                const eliteWeaponSample = ELITE_WEAPONS[getRandomInt(0, ELITE_WEAPONS.length - 1)];
                bonus.element.textContent = eliteWeaponSample.emoji.length > 1 && eliteWeaponSample.emoji.includes("️") ? eliteWeaponSample.emoji.substring(0, eliteWeaponSample.emoji.indexOf("️")) : eliteWeaponSample.emoji.substring(0,1); 
                bonus.element.title = `Элитное оружие: ${eliteWeaponSample.name}`;
                bonus.weapon = { ...eliteWeaponSample }; 
            } else if (type === 'armor_light') {
                bonus.element.classList.add('armor-pack');
                bonus.element.textContent = '🛡️';
                bonus.element.title = `Легкая Броня (${MAX_ARMOR_HITS_LIGHT} блока)`;
                bonus.hits = MAX_ARMOR_HITS_LIGHT;
            } else if (type === 'armor_heavy') {
                bonus.element.classList.add('armor-pack');
                bonus.element.textContent = '💠'; 
                bonus.element.title = `Тяжелая Броня (${MAX_ARMOR_HITS_HEAVY} блока)`;
                bonus.hits = MAX_ARMOR_HITS_HEAVY;
            }

            bonus.element.style.left = `${bonus.x - 20}px`; 
            bonus.element.style.top = `${bonus.y - 20}px`;
            arenaEl.appendChild(bonus.element);
            arenaBonuses.push(bonus);
        }

        function collectBonus(fighter, bonus) {
            logIntellectAction(fighter, 'resource', `подбирает ${bonus.element.title.split(':')[0]}`);
            addExperience(fighter, 'pickup_bonus');
            fighter.bonusesCollectedThisRound++;

            const aura = document.createElement('div');
            aura.classList.add('pickup-aura');
            if (bonus.type === 'health_pack') aura.classList.add('health');
            else if (bonus.type === 'elite_weapon') aura.classList.add('weapon');
            else if (bonus.type.includes('armor')) aura.classList.add('armor');
            
            if (fighter.element) fighter.element.appendChild(aura); // Check if element exists
            setTimeout(() => {if (aura.parentElement) aura.remove()}, 500); // Check parent


            if (bonus.type === 'health_pack') {
                fighter.health = Math.min(fighter.maxHealth, fighter.health + bonus.value);
                logMessage(`${fighter.name} <span class="log-bonus">исцеляется на ${bonus.value} ОЗ</span> от аптечки!`, "log-bonus");
            } else if (bonus.type === 'elite_weapon') {
                fighter.weapon = { ...bonus.weapon };
                fighter.weapon.currentRange = fighter.weapon.range; 
                logMessage(`${fighter.name} <span class="log-elite-weapon">подбирает Элитное Оружие: ${fighter.weapon.name} ${fighter.weapon.emoji}</span>!`, "log-elite-weapon");
                if (fighter.element) {
                    fighter.element.querySelector('.weapon-emoji').textContent = fighter.weapon.emoji;
                }
            } else if (bonus.type === 'armor_light' || bonus.type === 'armor_heavy') {
                fighter.armorHits = bonus.hits;
                if (activeRoundModifier && activeRoundModifier.name === "Хрупкая Броня") {
                    fighter.armorHits = Math.max(0, fighter.armorHits - 1); 
                     logMessage(`Модификатор "Хрупкая Броня" уменьшает прочность брони ${fighter.name}!`, "log-modifier");
                }
                fighter.maxArmorHits = bonus.hits; 
                fighter.hasArmor = fighter.armorHits > 0;
                logMessage(`${fighter.name} <span class="log-armor">надевает ${bonus.element.title}</span>! (${fighter.armorHits} блоков)`, "log-armor");
            }
            if (bonus.element && bonus.element.parentElement) bonus.element.remove(); // Check before removing
            arenaBonuses = arenaBonuses.filter(b => b.id !== bonus.id);
            updateFighterElement(fighter);
        }

        // --- STATUS EFFECTS & WEAPON SPECIALS ---
        function applyStatusEffect(target, effectType, details) {
            target.statusEffects[effectType] = { ...STATUS_EFFECT_DEFINITIONS[effectType], ...details };
            
            if (effectType === 'slow') target.speed = target.baseSpeed * (1 - details.factor);
            if (effectType === 'enrage') {
                target.damageOutputMultiplier *= details.damageMultiplier;
            }
            logMessage(`${target.name} получает эффект: <span class="log-effect">${effectType}</span> (длит: ${details.duration || 'мгновенно'})`, "log-effect");
            updateFighterElement(target); 
        }
        
        function applyWeaponSpecialEffects(attacker, target, weapon, actualDamageDealt) {
             if (!attacker.alive || !target.alive || !weapon.effects) return; // Added weapon.effects check

            weapon.effects.forEach(effect => {
                if (Math.random() < (effect.chance || 1.0)) { 
                    if (effect.type === 'lifesteal' && actualDamageDealt > 0) {
                        const healed = Math.round(actualDamageDealt * effect.percent);
                        if (healed > 0) {
                            attacker.health = Math.min(attacker.maxHealth, attacker.health + healed);
                            logMessage(`${attacker.name} <span class="log-bonus">восстанавливает ${healed} ОЗ</span> (${effect.type})!`, "log-bonus");
                            updateFighterElement(attacker);
                        }
                    } else if (effect.type === 'pull' || effect.type === 'push') {
                        const distEffect = effect.distance * (effect.type === 'pull' ? -1 : 1);
                        const dx = target.x - attacker.x;
                        const dy = target.y - attacker.y;
                        const currentDist = Math.sqrt(dx*dx + dy*dy);
                        if (currentDist > 0) {
                            target.x += (dx / currentDist) * distEffect;
                            target.y += (dy / currentDist) * distEffect;
                            target.x = Math.max(FIGHTER_WIDTH / 2, Math.min(ARENA_WIDTH - FIGHTER_WIDTH / 2, target.x));
                            target.y = Math.max(FIGHTER_HEIGHT / 2, Math.min(ARENA_HEIGHT - FIGHTER_HEIGHT / 2, target.y));
                            logMessage(`${attacker.name} ${effect.type === 'pull' ? 'притягивает' : 'отталкивает'} ${target.name}!`, "log-effect");
                            updateFighterElement(target);
                        }
                    }
                }
            });
        }


        function processStatusEffects(fighter) {
            for (const effectType in fighter.statusEffects) {
                const effect = fighter.statusEffects[effectType];
                
                if (['lifesteal', 'pull', 'push', 'armor_pierce'].includes(effectType)) {
                    if (effect.duration === undefined) { 
                         delete fighter.statusEffects[effectType];
                         continue;
                    }
                }
                
                if (effect.duration === undefined || isNaN(effect.duration)) { // Safety check for bad duration
                   console.warn("Invalid duration for effect:", effectType, effect);
                   delete fighter.statusEffects[effectType];
                   continue;
                }

                effect.duration--;

                if (effectType === 'poison' || effectType === 'burn') {
                    const dps = effect.dps;
                    applyDamage(fighter, dps, {name: effectType, id: `status-${effectType}`}, false, `${effectType} effect`); 
                    logMessage(`${fighter.name} получает ${dps} урона от <span class="log-${effectType === 'poison' ? 'poison' : 'damage'}">${effectType}</span>.`, `log-${effectType === 'poison' ? 'poison' : 'damage'}`);
                }

                if (effect.duration <= 0) {
                    if (effectType === 'slow' && fighter.speed) fighter.speed = fighter.baseSpeed; // Check speed exists
                    if (effectType === 'enrage' && fighter.damageOutputMultiplier) fighter.damageOutputMultiplier /= effect.damageMultiplier; // Check multiplier exists

                    delete fighter.statusEffects[effectType];
                    logMessage(`Эффект <span class="log-effect">${effectType}</span> на ${fighter.name} прошел.`, "log-effect");
                }
            }
            updateFighterElement(fighter);
        }
        
        // --- COMBAT ---
        function getPossibleTargets(attacker, allFighters) {
            return allFighters.filter(f => f.id !== attacker.id && f.alive);
        }

        function createProjectile(attacker, target, weapon) {
            const projectileEl = document.createElement('div');
            projectileEl.classList.add('projectile');
            projectileEl.textContent = weapon.projectile;
            projectileEl.style.left = `${attacker.x - 12}px`; 
            projectileEl.style.top = `${attacker.y - 12}px`; 
            arenaEl.appendChild(projectileEl);

            const dx = target.x - attacker.x;
            const dy = target.y - attacker.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const moveX = (dx / dist) * PROJECTILE_SPEED;
            const moveY = (dy / dist) * PROJECTILE_SPEED;
            
            let currentX = attacker.x;
            let currentY = attacker.y;
            const travelTicks = Math.max(1, Math.floor(dist / PROJECTILE_SPEED));
            let ticksPassed = 0;

            function animateProjectile() {
                if (!roundInProgress) { 
                     if (projectileEl.parentElement) projectileEl.remove();
                     return;
                }
                ticksPassed++;
                currentX += moveX;
                currentY += moveY;
                projectileEl.style.left = `${currentX - 12}px`;
                projectileEl.style.top = `${currentY - 12}px`;

                if (ticksPassed >= travelTicks) {
                    projectileEl.classList.add('hit-target');
                    setTimeout(() => {
                        if (projectileEl.parentElement) projectileEl.remove();
                    }, 120); 
                    
                    const finalTarget = currentFighters.find(f => f.id === target.id && f.alive);
                    if (finalTarget) {
                        const aoeRangedEffect = weapon.effects.find(e => e.type === 'aoe_ranged');
                        if (aoeRangedEffect) {
                            createAoeIndicator(finalTarget.x, finalTarget.y, aoeRangedEffect.radius);
                            let mainTargetHit = false;
                            currentFighters.filter(f => f.alive).forEach(potentialVictim => { 
                                if (getDistance({x: finalTarget.x, y: finalTarget.y}, potentialVictim) <= aoeRangedEffect.radius) {
                                    if (potentialVictim.id === attacker.id && aoeRangedEffect.selfImmune) return;
                                    
                                    let aoeDamageMultiplier = 1.0;
                                    if (potentialVictim.id !== finalTarget.id && aoeRangedEffect.subDamageFactor) {
                                        aoeDamageMultiplier = aoeRangedEffect.subDamageFactor;
                                    }
                                    if (potentialVictim.id === finalTarget.id) mainTargetHit = true;
                                    performAttackDamage(attacker, potentialVictim, weapon, aoeDamageMultiplier);
                                }
                            });
                            if (!mainTargetHit && finalTarget.alive) { 
                                performAttackDamage(attacker, finalTarget, weapon);
                            }

                        } else {
                            performAttackDamage(attacker, finalTarget, weapon);
                        }
                    }
                } else {
                    setTimeout(animateProjectile, Math.max(16, GAME_SPEED / (PROJECTILE_SPEED / 1.2) ) ); 
                }
            }
            animateProjectile();
        }

        function createAoeIndicator(x, y, radius) {
            const indicator = document.createElement('div');
            indicator.classList.add('aoe-indicator');
            indicator.style.width = `${radius * 2}px`;
            indicator.style.height = `${radius * 2}px`;
            indicator.style.left = `${x - radius}px`;
            indicator.style.top = `${y - radius}px`;
            arenaEl.appendChild(indicator);
            setTimeout(() => {
                if (indicator.parentElement) indicator.remove();
            }, 250); 
        }
        
        function performAttackDamage(attacker, target, weaponToUse, damageMultiplier = 1.0) {
            if (!target.alive || !attacker.alive || !weaponToUse) return; // Added weapon check
            lastDamageTimestamp = Date.now(); 

            const isCrit = Math.random() < weaponToUse.critChance;
            let damage = getRandomInt(weaponToUse.minDamage, weaponToUse.maxDamage);
            if (isCrit) damage = Math.round(damage * 1.5); 
            
            damage = Math.round(damage * attacker.damageOutputMultiplier * damageMultiplier); 
            
            const evasionRoll = Math.random();
            const targetEvasionChance = target.evasionChance + (target.combatStats.intellect.defense * 0.01); 
            
            const isAOE = weaponToUse.effects && weaponToUse.effects.some(e => e.type === 'aoe_melee' || e.type === 'aoe_ranged');

            if (!isAOE && evasionRoll < targetEvasionChance ) { 
                logMessage(`${target.name} <span class="log-evasion">уклоняется</span> от атаки ${attacker.name}!`, "log-evasion");
                addExperience(target, 'evade_attack');
                if (target.combatStats.intellect.defense > 2) logIntellectAction(target, 'defense', 'Уклонился!');
                return;
            }
            
            const armorPierceEffect = weaponToUse.effects ? weaponToUse.effects.find(e => e.type === 'armor_pierce') : null;
            const piercesArmor = armorPierceEffect && (Math.random() < (armorPierceEffect.chance || 1.0));


            const preMitigationDamage = damage; 
            applyDamage(target, damage, attacker, isCrit, weaponToUse.name, piercesArmor);

            // Apply standard status effects only if damage wasn't blocked by armor (or if it pierced)
            if (target.lastDamagedBy === attacker.id || piercesArmor) { // Check if damage went through
                 if (weaponToUse.effects && weaponToUse.effects.length > 0) {
                    weaponToUse.effects.forEach(effect => {
                        if (!['lifesteal', 'pull', 'push', 'aoe_melee', 'aoe_ranged', 'armor_pierce'].includes(effect.type)) { 
                            if (Math.random() < (effect.chance || 1.0)) {
                                applyStatusEffect(target, effect.type, { ...effect, sourceId: attacker.id });
                            }
                        }
                    });
                }
                applyWeaponSpecialEffects(attacker, target, weaponToUse, preMitigationDamage); 
            }
        }


        function applyDamage(target, damage, attacker, isCrit, sourceName = "атака", piercesArmor = false) {
            if (!target.alive) return;
            lastDamageTimestamp = Date.now(); 

            if (target.hasArmor && target.armorHits > 0 && !piercesArmor) {
                target.armorHits--;
                logMessage(`🛡️ <span class="log-armor-block">Броня ${target.name} поглощает удар от ${attacker.name}! (Осталось: ${target.armorHits})</span>`, "log-armor-block");
                
                if (target.element) { 
                    const flash = document.createElement('div');
                    flash.classList.add('damage-flash', 'blocked');
                    const imgEl = target.element.querySelector('img');
                    if (imgEl && imgEl.parentNode) { imgEl.parentNode.insertBefore(flash, imgEl.nextSibling); setTimeout(() => {if(flash.parentElement) flash.remove()}, 200); } // Added checks

                    const blockSpark = document.createElement('div');
                    blockSpark.classList.add('hit-spark', 'blocked');
                    blockSpark.style.left = `${target.x + getRandomInt(-10, 10)}px`;
                    blockSpark.style.top = `${target.y - FIGHTER_HEIGHT/2 + getRandomInt(-5, 5)}px`;
                    arenaEl.appendChild(blockSpark);
                    setTimeout(() => { if(blockSpark.parentElement) blockSpark.remove(); }, 200);
                }

                addExperience(target, 'block_attack');
                if (target.armorHits <= 0) { // Use <= 0 for safety
                    target.hasArmor = false;
                    target.maxArmorHits = 0;
                    logMessage(`💔 <span class="log-armor">Броня ${target.name} сломана!</span>`, "log-armor");
                }
                updateFighterElement(target);
                return; 
            }
            if (piercesArmor && target.hasArmor) {
                logMessage(`⚡ <span class="log-effect">${attacker.name} пробивает броню ${target.name}!</span>`, "log-effect");
            }


            damage = Math.round(damage * target.damageTakenMultiplier); 
            if (damage < 0) damage = 0; 

            target.health -= damage;
            target.lastDamagedBy = attacker.id; // Record attacker ID *after* armor check
            if (attacker.id && !attacker.id.startsWith('status-')) { 
                 const attackingFighter = currentFighters.find(f => f.id === attacker.id);
                 if (attackingFighter) attackingFighter.damageDealtThisRound += damage;
            }

            if (target.element) {
                const flash = document.createElement('div');
                flash.classList.add('damage-flash');
                flash.classList.add(isCrit ? 'critical' : 'normal');
                const imgEl = target.element.querySelector('img');
                if (imgEl && imgEl.parentNode) { // Added checks
                    imgEl.parentNode.insertBefore(flash, imgEl.nextSibling);
                    setTimeout(() => {if(flash.parentElement) flash.remove()}, 200);
                }
            }


            const damageSpark = document.createElement('div');
            damageSpark.classList.add('hit-spark');
            if (isCrit) damageSpark.classList.add('critical');
            damageSpark.style.left = `${target.x + getRandomInt(-10, 10)}px`;
            damageSpark.style.top = `${target.y - FIGHTER_HEIGHT/2 + getRandomInt(-5, 5)}px`;
            arenaEl.appendChild(damageSpark);
            setTimeout(() => { if(damageSpark.parentElement) damageSpark.remove(); }, isCrit ? 180: 150); 

            if (target.element) target.element.classList.add('hit');
            setTimeout(() => { if (target.element) target.element.classList.remove('hit'); }, 150); 

            const damageClass = isCrit ? "log-crit-damage" : "log-damage";
            logMessage(`${attacker.name} (${sourceName}) наносит <span class="${damageClass}">${damage}</span> урона ${target.name}. (ОЗ: ${Math.max(0, target.health)})`, damageClass);

            if (target.health <= 0) {
                target.health = 0;
                target.alive = false;
                if(target.element) target.element.classList.remove('breathing'); 
                defeatedFightersOrder.push(target.id);
                logMessage(`${target.name} <span class="log-kill">повержен</span> от руки ${attacker.name}!`, "log-kill");
                if (target.element) target.element.classList.add('defeated');
                
                if (attacker.id && !attacker.id.startsWith('status-')) { 
                    const attackingFighter = currentFighters.find(f => f.id === attacker.id);
                    if (attackingFighter) {
                        attackingFighter.killsThisRound++;
                        addExperience(attackingFighter, 'kill'); 
                        addExperience(attackingFighter, 'kill_major_boost'); 
                        if (attackingFighter.combatStats.learning.weaponEffectiveness[target.id]) {
                            attackingFighter.combatStats.learning.weaponEffectiveness[target.id]++;
                        } else {
                            attackingFighter.combatStats.learning.weaponEffectiveness[target.id] = 1;
                        }
                    }
                }
            } else {
                if (attacker.id && !attacker.id.startsWith('status-')) {
                    if (target.combatStats.learning.dangerousEnemies[attacker.id]) {
                        target.combatStats.learning.dangerousEnemies[attacker.id] += damage;
                    } else {
                        target.combatStats.learning.dangerousEnemies[attacker.id] = damage;
                    }
                }
            }
            updateFighterElement(target);
        }

        // --- AI AND ACTIONS --- (No changes needed here for the current request)
        function chooseAction(fighter, aliveFighters, bonuses) {
            if (fighter.actionCooldown > 0 || fighter.statusEffects.stun) return; 
            intelliActionLog[fighter.id] = null; 

            const { intellect, caution, aggression, preferredTargetType, learnedGrudges, learning } = fighter.combatStats;
            let bestAction = { type: 'idle', priority: -1 };

            if (bonuses.length > 0) {
                let closestBonus = null;
                let minDistToBonus = Infinity;
                bonuses.forEach(b => {
                    const d = getDistance(fighter, b);
                    if (d < minDistToBonus) {
                        minDistToBonus = d;
                        closestBonus = b;
                    }
                });

                if (closestBonus) {
                    let bonusPriority = 10; 
                    if (closestBonus.type === 'health_pack' && fighter.health < fighter.maxHealth * 0.6) { 
                        bonusPriority = 55 + (1 - fighter.health / fighter.maxHealth) * 50 + intellect.resource * 5;
                    } else if (closestBonus.type === 'elite_weapon' && (!fighter.weapon.name.includes("Элитное") && !ELITE_WEAPONS.some(ew => ew.name === fighter.weapon.name) )) { 
                        bonusPriority = 45 + intellect.resource * 6;
                    } else if (closestBonus.type.includes('armor') && !fighter.hasArmor) { 
                        bonusPriority = (closestBonus.type === 'armor_heavy' ? 50 : 40) + intellect.resource * 4;
                    }
                    
                    if (bonusPriority > bestAction.priority) {
                        bestAction = { type: 'pickup', targetBonus: closestBonus, priority: bonusPriority, message: `идет за ${closestBonus.element.title.split(':')[0]}` };
                    }
                }
            }
            
            const potentialTargets = getPossibleTargets(fighter, aliveFighters);
            if (potentialTargets.length > 0) {
                let currentTarget = null;
                let highestThreatScore = -Infinity;

                potentialTargets.forEach(pTarget => {
                    let score = 0;
                    const distToTarget = getDistance(fighter, pTarget);

                    if (preferredTargetType === 'closest') score += (ARENA_WIDTH - distToTarget) / 10;
                    if (preferredTargetType === 'weakest') score += (pTarget.maxHealth - pTarget.health) + (intellect.tactical * 5) - (pTarget.hasArmor ? 20 : 0) ; 
                    if (preferredTargetType === 'highest_threat') { 
                        score += (pTarget.combatStats.intellect.tactical * 3) + (pTarget.wins * 5) + (pTarget.hasArmor ? 10 : 0); 
                        if (pTarget.target && pTarget.target.id === fighter.id) score += 20; 
                    }
                    if (preferredTargetType === 'random' && !currentTarget) { 
                        currentTarget = pTarget;
                    }
                    
                    score += intellect.tactical * 2; 
                    if (learnedGrudges[pTarget.id]) score += learnedGrudges[pTarget.id] * (5 + intellect.tactical); 
                    if (learning.dangerousEnemies[pTarget.id] && learning.dangerousEnemies[pTarget.id] > fighter.health * 0.2) {
                        score += 10 + intellect.tactical * 2; 
                    }
                    if (learning.weaponEffectiveness[pTarget.id] && learning.weaponEffectiveness[pTarget.id] > 0) {
                        score += 5 + intellect.tactical;
                    }
                    score *= (1 + aggression - caution);
                    if (score > highestThreatScore) {
                        highestThreatScore = score;
                        currentTarget = pTarget;
                    }
                });
                
                if (preferredTargetType === 'random' && potentialTargets.length > 0 && !currentTarget) {
                    currentTarget = potentialTargets[getRandomInt(0, potentialTargets.length-1)];
                }

                if (currentTarget) {
                    fighter.target = currentTarget; 
                    const distToTarget = getDistance(fighter, currentTarget);
                    const attackRange = fighter.weapon.currentRange;

                    if (distToTarget <= attackRange) {
                        let attackPriority = 35 + intellect.tactical * 5 + aggression * 25; 
                        if (currentTarget.health < currentTarget.maxHealth * 0.25 && fighter.health > fighter.maxHealth * 0.15) {
                            attackPriority += 40 + aggression * 10; 
                            if(intellect.tactical > 2) logIntellectAction(fighter, 'tactical', `добивает ${currentTarget.name}!`);
                        }
                        if (fighter.health < fighter.maxHealth * 0.20 && caution > aggression * 1.1) { 
                             attackPriority *= (0.5 - caution * 1.5); 
                        }
                        if (attackPriority > bestAction.priority) {
                           bestAction = { type: 'attack', target: currentTarget, priority: attackPriority, message: `атакует ${currentTarget.name}` };
                        }
                    } else { 
                        let moveAttackPriority = 25 + intellect.spatial * 3 + aggression * 20;
                        if (currentTarget.health < currentTarget.maxHealth * 0.25 && fighter.health > fighter.maxHealth * 0.15) {
                            moveAttackPriority += 30 + aggression * 5; 
                        }
                         if (moveAttackPriority > bestAction.priority) {
                            bestAction = { type: 'move_to_attack', target: currentTarget, priority: moveAttackPriority, message: `сближается с ${currentTarget.name}` };
                        }
                    }
                }
            }

            let wantsToRetreat = false;
            let retreatPriority = -1;
            
            if (fighter.health < fighter.maxHealth * (0.20 + caution * 0.6 - aggression * 0.3 + intellect.defense * 0.03)) { 
                wantsToRetreat = true;
            }
            if (fighter.hasArmor && fighter.armorHits > 0 && fighter.health > fighter.maxHealth * 0.1) {
                wantsToRetreat = false;
            }
            
            if (fighter.target && fighter.target.health < fighter.target.maxHealth * 0.10 && fighter.health > fighter.maxHealth * 0.10) {
                wantsToRetreat = false;
            }
            if (duelContenders && duelContenders.includes(fighter) && fighter.health > fighter.maxHealth * 0.05) { 
                 wantsToRetreat = false; 
            } else if (aggression > 0.95 && fighter.health > fighter.maxHealth * 0.03) { 
                if (Math.random() < aggression * 0.9) wantsToRetreat = false; 
            }


            if (wantsToRetreat && potentialTargets.length > 0) {
                let escapeVector = { x: 0, y: 0 };
                let closestThreatDist = Infinity;
                let closestThreat = null;
                let numThreatsConsidered = 0;

                potentialTargets.forEach(pTarget => {
                    const dist = getDistance(fighter, pTarget);
                    if (dist < fighter.weapon.range * 2.0 || (pTarget.target && pTarget.target.id === fighter.id)) { 
                        numThreatsConsidered++;
                        if (dist < closestThreatDist) {
                            closestThreatDist = dist;
                            closestThreat = pTarget;
                        }
                        escapeVector.x -= (pTarget.x - fighter.x) / (dist * dist + 1);
                        escapeVector.y -= (pTarget.y - fighter.y) / (dist * dist + 1);
                    }
                });
                
                if (numThreatsConsidered > 0) { 
                    let retreatDestX = fighter.x, retreatDestY = fighter.y;
                    const norm = Math.sqrt(escapeVector.x * escapeVector.x + escapeVector.y * escapeVector.y);
                    if (norm > 0) {
                        retreatDestX = fighter.x + (escapeVector.x / norm) * fighter.speed * 2.5; 
                        retreatDestY = fighter.y + (escapeVector.y / norm) * fighter.speed * 2.5;
                    } else if (closestThreat) { 
                        retreatDestX = fighter.x + (fighter.x - closestThreat.x) / closestThreatDist * fighter.speed * 2.5;
                        retreatDestY = fighter.y + (fighter.y - closestThreat.y) / closestThreatDist * fighter.speed * 2.5;
                    }

                    retreatPriority = 30 + intellect.defense * 6 + caution * 20 - aggression * 25; 
                    if (aggression > 0.9) retreatPriority -= (aggression - 0.9) * 120; 
                    if (duelContenders && duelContenders.includes(fighter) && fighter.health > fighter.maxHealth * 0.05) retreatPriority -= 60;
                    
                    if (fighter.target && fighter.target.health < fighter.target.maxHealth * 0.10) {
                        retreatPriority -= 30; 
                    }

                    if (retreatPriority > bestAction.priority) {
                        bestAction = { type: 'retreat', destX: retreatDestX, destY: retreatDestY, priority: retreatPriority, message: `отступает` };
                    }
                }
            }

            if (bestAction.type === 'idle' || bestAction.priority < (8 + intellect.spatial * 2)) { 
                let destX = fighter.x + getRandomInt(-1, 1) * fighter.speed * (1 + intellect.spatial * 0.1);
                let destY = fighter.y + getRandomInt(-1, 1) * fighter.speed * (1 + intellect.spatial * 0.1);
                
                if (fighter.x < 50) destX = fighter.x + fighter.speed * 1.5;
                if (fighter.x > ARENA_WIDTH - 50) destX = fighter.x - fighter.speed * 1.5;
                if (fighter.y < 50) destY = fighter.y + fighter.speed * 1.5;
                if (fighter.y > ARENA_HEIGHT - 50) destY = fighter.y - fighter.speed * 1.5;

                bestAction = { type: 'reposition', destX, destY, priority: 5 + intellect.spatial * 2, message: `маневрирует` };
            }

            fighter.currentAction = bestAction;
            if (bestAction.type !== 'idle' && bestAction.message && intellect[bestAction.type === 'attack' || bestAction.type === 'move_to_attack' ? 'tactical' : bestAction.type === 'pickup' ? 'resource' : bestAction.type === 'retreat' ? 'defense' : 'spatial'] > 1) {
                const intellectContext = bestAction.type === 'attack' || bestAction.type === 'move_to_attack' ? 'tactical' :
                                       bestAction.type === 'pickup' ? 'resource' :
                                       bestAction.type === 'retreat' ? 'defense' : 'spatial';
                logIntellectAction(fighter, intellectContext, bestAction.message);
            }
        }


        function executeAction(fighter) {
            if (!fighter.alive || fighter.actionCooldown > 0 || fighter.statusEffects.stun || !fighter.currentAction) return;

            const action = fighter.currentAction;
            let targetFighter = null;
            if (action.target) targetFighter = currentFighters.find(f => f.id === action.target.id && f.alive);

            let targetBonus = null;
            if(action.targetBonus) targetBonus = arenaBonuses.find(b => b.id === action.targetBonus.id);

            let moveSpeed = fighter.speed;
            if (fighter.statusEffects.root) moveSpeed = 0;


            switch (action.type) {
                case 'attack':
                    if (targetFighter) {
                        if (fighter.element) fighter.element.classList.add('attacking');
                        setTimeout(() => { if(fighter.element) fighter.element.classList.remove('attacking'); }, 100); 

                        const aoeMeleeEffect = fighter.weapon.effects ? fighter.weapon.effects.find(e => e.type === 'aoe_melee') : null;

                        if (aoeMeleeEffect) { 
                            createAoeIndicator(fighter.x, fighter.y, aoeMeleeEffect.radius);
                            let targetsHit = 0;
                            getPossibleTargets(fighter, currentFighters).forEach(potentialVictim => {
                                if (getDistance(fighter, potentialVictim) <= aoeMeleeEffect.radius) {
                                    let damageMult = (potentialVictim.id === targetFighter.id) ? 1.0 : (aoeMeleeEffect.subDamageFactor || 0.7);
                                    performAttackDamage(fighter, potentialVictim, fighter.weapon, damageMult);
                                    targetsHit++;
                                }
                            });
                            if (targetsHit > 1) addExperience(fighter, 'aoe_hit_multiple', (targetsHit -1));
                        } else if (fighter.weapon.type === 'melee') {
                            performAttackDamage(fighter, targetFighter, fighter.weapon);
                        } else if (fighter.weapon.type === 'ranged') {
                            createProjectile(fighter, targetFighter, fighter.weapon);
                        }
                        fighter.actionCooldown = Math.max(1, Math.round( (10 / fighter.weapon.speed) / 2) ); 
                    }
                    break;
                case 'move_to_attack':
                case 'retreat':
                case 'reposition':
                    if (moveSpeed > 0) {
                        let destX = action.destX;
                        let destY = action.destY;
                        if (action.type === 'move_to_attack' && targetFighter) {
                            destX = targetFighter.x;
                            destY = targetFighter.y;
                        }

                        const dx = destX - fighter.x;
                        const dy = destY - fighter.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > moveSpeed) {
                            fighter.x += (dx / dist) * moveSpeed;
                            fighter.y += (dy / dist) * moveSpeed;
                        } else {
                            fighter.x = destX;
                            fighter.y = destY;
                            if (action.type === 'retreat' || action.type === 'reposition') fighter.currentAction = null; 
                        }
                        fighter.x = Math.max(FIGHTER_WIDTH / 2, Math.min(ARENA_WIDTH - FIGHTER_WIDTH / 2, fighter.x));
                        fighter.y = Math.max(FIGHTER_HEIGHT / 2, Math.min(ARENA_HEIGHT - FIGHTER_HEIGHT / 2, fighter.y));
                    }
                     fighter.actionCooldown = 1; 
                    break;
                case 'pickup':
                    if (targetBonus && moveSpeed > 0) {
                        const distToBonus = getDistance(fighter, targetBonus);
                        if (distToBonus <= BONUS_PICKUP_RADIUS) {
                            collectBonus(fighter, targetBonus);
                            fighter.currentAction = null; 
                        } else {
                            const dx = targetBonus.x - fighter.x;
                            const dy = targetBonus.y - fighter.y;
                            if (distToBonus > moveSpeed) {
                                fighter.x += (dx / distToBonus) * moveSpeed;
                                fighter.y += (dy / distToBonus) * moveSpeed;
                            } else {
                                fighter.x = targetBonus.x;
                                fighter.y = targetBonus.y;
                            }
                            fighter.x = Math.max(FIGHTER_WIDTH / 2, Math.min(ARENA_WIDTH - FIGHTER_WIDTH / 2, fighter.x));
                            fighter.y = Math.max(FIGHTER_HEIGHT / 2, Math.min(ARENA_HEIGHT - FIGHTER_HEIGHT / 2, fighter.y));
                        }
                    } else if (!targetBonus) { 
                        fighter.currentAction = null;
                    }
                    fighter.actionCooldown = 1;
                    break;
                case 'idle':
                default:
                    fighter.actionCooldown = 1; 
                    break;
            }
            if(fighter.actionCooldown > 0 && fighter.currentAction && fighter.currentAction.type === 'attack') {
                if (targetFighter && fighter.combatStats.learnedGrudges[targetFighter.id]) {
                    fighter.combatStats.learnedGrudges[targetFighter.id]++;
                } else if (targetFighter) {
                    fighter.combatStats.learnedGrudges[targetFighter.id] = 1;
                }
            }
        }


        // --- GAME FLOW ---
        function setupNewRound(isContinuation = false, isManualRestart = false) { 
            if (isGameOver && !isManualRestart) return; 
            if (isManualRestart) isGameOver = false; 

            console.log("--- Starting setupNewRound --- isContinuation:", isContinuation, "isManualRestart:", isManualRestart);
            
            roundInProgress = false;
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            if (preRoundTimeoutId) clearTimeout(preRoundTimeoutId);

            arenaEl.innerHTML = ''; 
            arenaBonuses.forEach(b => { if (b.element && b.element.parentElement) b.element.remove(); });
            arenaBonuses = [];
            currentFighters = [];
            duelContenders = null;
            activeRoundModifier = null;
            intelliActionLog = {}; 
            defeatedFightersOrder = [];
            createFighterInstance.commonWeaponThisRound = null; 
            lastDamageTimestamp = Date.now(); 

            if (!isManualRestart) { 
                playerGold += GOLD_PER_ROUND_BONUS;
            }
            currentBet = { fighterId: null, amount: 0, placed: false };
            isBettingPaused = false; 
            updatePlayerGoldDisplay();

            if (bettingModalEl) bettingModalEl.style.display = 'none';
            if (gameOverOverlayEl) gameOverOverlayEl.style.display = 'none'; 


            if (!isContinuation && !isManualRestart) roundCounter = 0;
            if (!isManualRestart) roundCounter++; 

            // Update title
            document.title = `Арена Гладиаторов: Раунд ${roundCounter}`;
            const h1Title = document.querySelector('h1');
            if (h1Title) h1Title.textContent = `Арена Гладиаторов: Раунд ${roundCounter}`;


            if (!isContinuation && !isManualRestart) battleLogEl.innerHTML = '';
            logMessage(`⚔️ Раунд ${roundCounter} начинается! Бойцы готовятся...`, "log-round-start");

            activeRoundModifier = null; 
            if (roundCounter > 1 && Math.random() < MODIFIER_CHANCE_PER_ROUND) {
                activeRoundModifier = roundModifiers[getRandomInt(0, roundModifiers.length - 1)];
                logMessage(`🔮 МОДИФИКАТОР РАУНДА: <span class="log-modifier">${activeRoundModifier.name}</span>`, "log-modifier");
                logMessage(`<i>${activeRoundModifier.description}</i>`, "log-modifier");
            }
            
            if (roundCounter > 0 && roundCounter % 5 === 0) {
                logMessage("💥 <span class='log-winner'>Спец-раунд! Все бойцы получают одинаковое оружие!</span>", "log-winner");
            }


            const participatingFightersData = fightersInitialData.filter(fData => fData.participating);
            if (participatingFightersData.length < 2) {
                logMessage("Недостаточно бойцов для начала раунда (нужно минимум 2). Отметьте участников в таблице.", "log-kill");
                startButtonEl.textContent = 'Нужно больше бойцов!';
                startButtonEl.disabled = false;
                restartRoundButtonEl.style.display = 'none';
                firstRoundStarted = false; 
                if (!isManualRestart) roundCounter--; // Decrement only if it wasn't a failed manual restart setup
                document.title = `Арена Гладиаторов`; // Reset title
                 if (h1Title) h1Title.textContent = `Арена Гладиаторов`;
                return;
            }

            currentFighters = participatingFightersData.map(data => createFighterInstance(data));
            
            if (activeRoundModifier && activeRoundModifier.apply) { 
                currentFighters.forEach(f => activeRoundModifier.apply(f));
            }


            const allFightersAreActuallyParticipating = fightersInitialData.length === participatingFightersData.length && fightersInitialData.every(f => f.participating);

            if (placeBetButtonEl) {
                if (allFightersAreActuallyParticipating && currentFighters.length >= 2) {
                    placeBetButtonEl.style.display = 'block';
                    logMessage("💰 Доступны ставки на этот раунд! (Все бойцы участвуют)", "log-bonus");
                } else {
                    placeBetButtonEl.style.display = 'none';
                    if (!allFightersAreActuallyParticipating) logMessage("Ставки недоступны: не все бойцы участвуют.", "log-effect");
                    else logMessage("Ставки недоступны: недостаточно бойцов.", "log-effect");
                }
            }
            
            const highestIntellectFighter = currentFighters.reduce((prev, current) => getTotalIntellect(prev) > getTotalIntellect(current) ? prev : current, currentFighters[0]);
            if (highestIntellectFighter && getTotalIntellect(highestIntellectFighter) >= 10) { 
                let intellectSummary = `(${INTELLECT_SYMBOLS.tactical}${highestIntellectFighter.combatStats.intellect.tactical} ${INTELLECT_SYMBOLS.defense}${highestIntellectFighter.combatStats.intellect.defense} ${INTELLECT_SYMBOLS.resource}${highestIntellectFighter.combatStats.intellect.resource} ${INTELLECT_SYMBOLS.spatial}${highestIntellectFighter.combatStats.intellect.spatial})`;
                logMessage(`🧠 <span class="log-winner">${highestIntellectFighter.name}</span> выделяется высоким интеллектом ${intellectSummary}!`, "log-winner");
            }


            weaponInfoListEl.innerHTML = '';
            currentFighters.forEach(fighter => {
                createFighterElement(fighter); 
                const li = document.createElement('li');
                
                let intellectInfo = "";
                const totalInt = getTotalIntellect(fighter);
                if (totalInt > 4) { 
                    intellectInfo = `<span class="fighter-intellect-info">(`;
                    if (fighter.combatStats.intellect.tactical > 1) intellectInfo += `<span class="int-tactical">${INTELLECT_SYMBOLS.tactical}${fighter.combatStats.intellect.tactical}</span>`;
                    if (fighter.combatStats.intellect.defense > 1) intellectInfo += `<span class="int-defense">${INTELLECT_SYMBOLS.defense}${fighter.combatStats.intellect.defense}</span>`;
                    if (fighter.combatStats.intellect.resource > 1) intellectInfo += `<span class="int-resource">${INTELLECT_SYMBOLS.resource}${fighter.combatStats.intellect.resource}</span>`;
                    if (fighter.combatStats.intellect.spatial > 1) intellectInfo += `<span class="int-spatial">${INTELLECT_SYMBOLS.spatial}${fighter.combatStats.intellect.spatial}</span>`;
                    intellectInfo += `)</span>`;
                }
                
                li.innerHTML = `<span class="fighter-name-info">${fighter.name}</span>${intellectInfo} вооружен: <span class="weapon-name-info">${fighter.weapon.name}</span> <span class="weapon-emoji-info">${fighter.weapon.emoji}</span>`;
                weaponInfoListEl.appendChild(li);
            });

            roundInfoOverlayEl.style.display = 'flex';
            startButtonEl.textContent = 'Раунд Идет...';
            startButtonEl.disabled = true;
            restartRoundButtonEl.style.display = 'block'; 
            restartRoundButtonEl.disabled = false;
            updateScoreboard(); 

            preRoundTimeoutId = setTimeout(() => {
                if (!isBettingPaused) { 
                    proceedToRoundStart();
                }
            }, PRE_ROUND_WEAPON_DISPLAY_DURATION);
        }

        function proceedToRoundStart() {
            if(isGameOver) return;
            roundInfoOverlayEl.style.display = 'none';
            logMessage("БОЙ НАЧИНАЕТСЯ!", "log-round-start");
            roundInProgress = true;
            lastDamageTimestamp = Date.now(); 
            updateScoreboard(); 
            gameLoopInterval = setInterval(gameTick, GAME_SPEED);
        }

        function gameTick() {
            if (!roundInProgress || isGameOver) return;
            intelliActionLog = {}; 

            const aliveFighters = currentFighters.filter(f => f.alive);

            // Stall detection based on lack of damage
            if (Date.now() - lastDamageTimestamp > STALL_TIMEOUT && aliveFighters.length > 1 && !duelContenders) {
                logMessage("⏳ <span class='log-stall-restart'>Бездействие на арене более 10 секунд! Раунд перезапускается...</span>", "log-stall-restart");
                endRound(true); // Pass true to indicate a stall restart
                return;
            }


            if (duelContenders) {
                const [fighter1, fighter2] = duelContenders;
                if (!fighter1.alive || !fighter2.alive) {
                    const duelWinner = fighter1.alive ? fighter1 : (fighter2.alive ? fighter2 : null);
                    const duelLoser = fighter1.alive ? fighter2 : fighter1;
                    if (duelWinner) {
                        logMessage(`👑 <span class="log-winner">${duelWinner.name}</span> побеждает в дуэли против ${duelLoser.name}!`, "log-winner");
                        addExperience(duelWinner, 'defeat_dangerous_enemy');
                        if (getTotalIntellect(duelWinner) >= 10) logIntellectAction(duelWinner, 'tactical', `выиграл дуэль!`);
                    } else {
                        logMessage(`💔 Дуэль между ${fighter1.name} и ${fighter2.name} завершилась без явного победителя (оба пали?).`, "log-winner");
                    }
                    duelContenders = null; 
                }
            }
            
            if (aliveFighters.length <= 1 && roundInProgress) { 
                endRound();
                return;
            }

            aliveFighters.forEach(fighter => {
                if (!fighter.alive) return;

                fighter.ticksSurvivedThisRound++;
                if (fighter.actionCooldown > 0) fighter.actionCooldown--;
                
                processStatusEffects(fighter); 
                if (activeRoundModifier && activeRoundModifier.applyTick) {
                    activeRoundModifier.applyTick(fighter);
                }

                if (fighter.alive && fighter.actionCooldown <= 0 && !fighter.statusEffects.stun) {
                    chooseAction(fighter, aliveFighters, arenaBonuses);
                    executeAction(fighter);
                }
                updateFighterElement(fighter); 
            });
            
            manageArenaBonuses();

            if (!duelContenders && aliveFighters.length === 2) {
                duelContenders = [...aliveFighters]; 
                logMessage(`⚔️ <span class="log-duel">ДУЭЛЬ!</span> ${duelContenders[0].name} против ${duelContenders[1].name}!`, "log-duel");
                duelContenders.forEach(f => {
                    addExperience(f, 'target_priority_success'); 
                    if(getTotalIntellect(f) >= 8) logIntellectAction(f, 'tactical', `вступает в дуэль!`);
                });
            }
        }

        function endRound(isStallRestart = false) { 
            // Check if round already ended to prevent double execution from stall + normal end
            if (!roundInProgress && !isStallRestart) return; 
            
            console.log("--- Starting endRound --- Stall Restart:", isStallRestart);
            roundInProgress = false; 
            restartRoundButtonEl.disabled = true; // Disable manual restart during end-of-round processing
            if (gameLoopInterval) clearInterval(gameLoopInterval);

            if (isStallRestart) {
                logMessage(`Подготовка к перезапуску раунда ${roundCounter}...`, "log-round-start");
                preRoundTimeoutId = setTimeout(() => {
                    if (isGameOver) return; // Should be false here after setupNewRound resets it
                    setupNewRound(true, true); 
                }, NEW_ROUND_DELAY / 2); 
                return; // Skip normal end-round logic
            }

            // --- Normal End Round Logic ---
            const aliveFightersCurrent = currentFighters.filter(f => f.alive); 
            let winner = null;

            if (aliveFightersCurrent.length === 1) {
                winner = aliveFightersCurrent[0];
                logMessage(`🎉 <span class="log-winner">${winner.name}</span> ПОБЕЖДАЕТ В РАУНДЕ ${roundCounter}!`, "log-winner");
                const winnerData = fightersInitialData.find(f => f.id === winner.id);
                if (winnerData) winnerData.wins++;
                
                const totalInt = getTotalIntellect(winner);
                if (totalInt >= 12) { 
                     let intellectSummary = `(${INTELLECT_SYMBOLS.tactical}${winner.combatStats.intellect.tactical} ${INTELLECT_SYMBOLS.defense}${winner.combatStats.intellect.defense} ${INTELLECT_SYMBOLS.resource}${winner.combatStats.intellect.resource} ${INTELLECT_SYMBOLS.spatial}${winner.combatStats.intellect.spatial})`;
                     logMessage(`🧠 Интеллект победителя: <span class="log-winner">${intellectSummary}</span>`, "log-winner");
                }

            } else if (aliveFightersCurrent.length === 0) {
                logMessage(`💔 Все бойцы пали в раунде ${roundCounter}! Ничья...`, "log-winner");
            } else {
                // This case should ideally not happen if stall detection works, but keep it as a fallback
                logMessage(`🤔 Раунд ${roundCounter} завершен (${aliveFightersCurrent.length} выживших). Неопределенный исход.`, "log-winner");
            }

            // Process bets
            if (currentBet.placed && currentBet.fighterId && currentBet.amount > 0) {
                let payoutMultiplier = 0;
                let placeTaken = 0; 
                const betOnFighterData = fightersInitialData.find(f => f.id === currentBet.fighterId);
                const betOnFighterName = betOnFighterData ? betOnFighterData.name : "Боец";

                if (winner && winner.id === currentBet.fighterId) {
                    payoutMultiplier = 10; placeTaken = 1;
                } else {
                    const actualTotalFighters = currentFighters.length;
                    if (winner) { 
                        if (defeatedFightersOrder.length > 0 && defeatedFightersOrder[defeatedFightersOrder.length - 1] === currentBet.fighterId) {
                            payoutMultiplier = 5; placeTaken = 2;
                        } else if (defeatedFightersOrder.length > 1 && defeatedFightersOrder[defeatedFightersOrder.length - 2] === currentBet.fighterId) {
                            payoutMultiplier = 3; placeTaken = 3;
                        }
                    } else if (actualTotalFighters === defeatedFightersOrder.length) { 
                        if (defeatedFightersOrder.length >=1 && defeatedFightersOrder[defeatedFightersOrder.length - 1] === currentBet.fighterId) { 
                            payoutMultiplier = 10; placeTaken = 1; 
                        } else if (defeatedFightersOrder.length >=2 && defeatedFightersOrder[defeatedFightersOrder.length - 2] === currentBet.fighterId) {
                            payoutMultiplier = 5; placeTaken = 2;
                        } else if (defeatedFightersOrder.length >=3 && defeatedFightersOrder[defeatedFightersOrder.length - 3] === currentBet.fighterId) {
                            payoutMultiplier = 3; placeTaken = 3;
                        }
                    }
                }

                if (payoutMultiplier > 0) {
                    const winnings = currentBet.amount * payoutMultiplier;
                    playerGold += winnings;
                    logMessage(`💰 ПОЗДРАВЛЯЕМ! Ваша ставка на <span class="log-winner">${betOnFighterName}</span> (${placeTaken}-е место) выиграла! Вы получаете ${winnings.toLocaleString()} золота!`, "log-winner");
                } else {
                    logMessage(`💔 Ваша ставка на <span class="log-damage">${betOnFighterName}</span> не сыграла.`, "log-damage");
                }
            }
            currentBet = { fighterId: null, amount: 0, placed: false }; 
            updatePlayerGoldDisplay();

            processRoundExperience(); 

            // Save learning/intellect back to base data
            currentFighters.forEach(cf => {
                const fData = fightersInitialData.find(f => f.id === cf.id);
                if (fData) {
                    fData.combatStats.learnedGrudges = { ...cf.combatStats.learnedGrudges };
                    fData.combatStats.learning = JSON.parse(JSON.stringify(cf.combatStats.learning));
                    fData.combatStats.intellect = JSON.parse(JSON.stringify(cf.combatStats.intellect));
                    fData.combatStats.experience = JSON.parse(JSON.stringify(cf.combatStats.experience));
                }
            });
            
            // Remove modifier effects from the *fighter instances*
            if (activeRoundModifier && activeRoundModifier.remove) {
                 currentFighters.forEach(f => { // Iterate over current instances
                    if (f) activeRoundModifier.remove(f); // Pass the instance 'f', not 'fData'
                 });
            }

            updateScoreboard(); 

            currentFighters.forEach(f => { 
                if (!f.alive && f.element) {
                    f.element.classList.add('defeated');
                    f.element.classList.remove('breathing');
                }
            });

            if (isGameOver) return; 

            logMessage(`Подготовка к раунду ${roundCounter + 1}...`, "log-round-start");
            preRoundTimeoutId = setTimeout(() => {
                if (isGameOver) return;
                setupNewRound(true); 
            }, NEW_ROUND_DELAY);
        }

        // --- INITIALIZATION ---
        function initGame() {
            document.title = "Арена Гладиаторов"; // Set initial title
            const h1Title = document.querySelector('h1');
            if (h1Title) h1Title.textContent = `Арена Гладиаторов`;

            startButtonEl.addEventListener('click', () => {
                if (isGameOver) return;
                if ((!firstRoundStarted && !roundInProgress) || startButtonEl.textContent === 'Нужно больше бойцов!' || startButtonEl.textContent === 'Ошибка! Перезапустить?') {
                    firstRoundStarted = true;
                    startButtonEl.textContent = 'Подготовка...';
                    startButtonEl.disabled = true;
                    restartRoundButtonEl.style.display = 'none'; 
                    setupNewRound(false); 
                }
            });
            
            restartRoundButtonEl.addEventListener('click', () => {
                 // Allow restart even if game over state was briefly set by a stall, but before player interaction
                if (!roundInProgress && !firstRoundStarted && !isGameOver) {
                     alert("Сначала начните игру!");
                     return;
                }
                 
                if (confirm("Перезапустить текущий раунд? Текущий прогресс раунда (опыт, ставки) будет потерян.")) {
                    logMessage("🏁 <span class='log-stall-restart'>Раунд перезапускается вручную...</span>", "log-stall-restart");
                    endRound(true); // Trigger stall-like restart logic
                }
            });


            placeBetButtonEl.addEventListener('click', () => {
                if (isGameOver || roundInProgress) return;

                const participatingCount = fightersInitialData.filter(f => f.participating).length;
                if (fightersInitialData.length !== participatingCount || participatingCount < 2) {
                     alert("Ставки доступны только когда все бойцы участвуют и их минимум двое.");
                     placeBetButtonEl.style.display = 'none'; 
                     return;
                }

                isBettingPaused = true;
                if (preRoundTimeoutId) clearTimeout(preRoundTimeoutId);

                betFighterSelectEl.innerHTML = '';
                currentFighters.filter(f => f.alive).forEach(f => { 
                    const option = document.createElement('option');
                    option.value = f.id;
                    let intellectInfo = "";
                    const totalInt = getTotalIntellect(f);
                     if (totalInt > 4) {
                        intellectInfo = ` (${INTELLECT_SYMBOLS.tactical}${f.combatStats.intellect.tactical}, ${INTELLECT_SYMBOLS.defense}${f.combatStats.intellect.defense}, ${INTELLECT_SYMBOLS.resource}${f.combatStats.intellect.resource}, ${INTELLECT_SYMBOLS.spatial}${f.combatStats.intellect.spatial})`;
                    }
                    option.textContent = f.name + intellectInfo;
                    betFighterSelectEl.appendChild(option);
                });
                betAmountInputEl.value = '';
                betAmountInputEl.max = playerGold;
                betErrorMessageEl.textContent = '';
                updatePlayerGoldDisplay(); 
                bettingModalEl.style.display = 'flex';
            });

            confirmBetButtonEl.addEventListener('click', () => {
                if (isGameOver) return;
                const selectedFighterId = betFighterSelectEl.value;
                const betAmount = parseInt(betAmountInputEl.value);

                betErrorMessageEl.textContent = '';
                if (!selectedFighterId) { betErrorMessageEl.textContent = 'Выберите бойца.'; return; }
                if (isNaN(betAmount) || betAmount <= 0) { betErrorMessageEl.textContent = 'Введите корректную сумму.'; return; }
                if (betAmount > playerGold) { betErrorMessageEl.textContent = 'Недостаточно золота.'; return; }

                currentBet.fighterId = selectedFighterId;
                currentBet.amount = betAmount;
                currentBet.placed = true;
                playerGold -= betAmount;
                updatePlayerGoldDisplay();
                const fighterBetOn = currentFighters.find(f => f.id === selectedFighterId);
                logMessage(`💰 Вы поставили ${betAmount.toLocaleString()} золота на <span class="log-winner">${fighterBetOn ? fighterBetOn.name : 'бойца'}</span>!`);
                
                bettingModalEl.style.display = 'none';
                isBettingPaused = false;
                proceedToRoundStart(); 
            });

            skipBetButtonEl.addEventListener('click', () => {
                if (isGameOver) return;
                bettingModalEl.style.display = 'none';
                isBettingPaused = false;
                proceedToRoundStart();
            });
            
            buyLandButtonEl.addEventListener('click', () => {
                if (playerGold >= WIN_AMOUNT_FOR_LAND && !isGameOver) {
                    playerGold -= WIN_AMOUNT_FOR_LAND;
                    updatePlayerGoldDisplay();
                    isGameOver = true;
                    if (gameLoopInterval) clearInterval(gameLoopInterval);
                    if (preRoundTimeoutId) clearTimeout(preRoundTimeoutId);
                    roundInProgress = false;
                    startButtonEl.disabled = true;
                    startButtonEl.textContent = "ИГРА ОКОНЧЕНА";
                    restartRoundButtonEl.style.display = 'none';
                    roundInfoOverlayEl.style.display = 'none';
                    bettingModalEl.style.display = 'none';
                    arenaEl.innerHTML = '<p style="text-align:center; font-size: 3em; color: var(--warning-color); margin-top: 200px;">👑 Вы Бог! 👑</p>';
                    battleLogEl.innerHTML = '';
                    logMessage(`ПОЗДРАВЛЯЕМ! ВЫ ПОТРАТИЛИ ${WIN_AMOUNT_FOR_LAND.toLocaleString()} 💰, КУПИЛИ ЗЕМЛЮ И СТАЛИ БОГОМ!`, "log-winner");
                    gameOverOverlayEl.style.display = 'flex';
                    updateScoreboard(); 
                } else if (!isGameOver) {
                    alert(`Недостаточно золота! Нужно ${WIN_AMOUNT_FOR_LAND.toLocaleString()} 💰.`);
                }
            });

            updateScoreboard();
            updatePlayerGoldDisplay();
            logMessage("Ожидание начала первой битвы...");
            logMessage("🧠 <span class='log-winner'>Гладиаторы теперь обладают интеллектом и будут становиться умнее с каждым боем!</span>", "log-winner");
            logMessage("🛡️ <span class='log-armor'>На арене теперь может появляться броня!</span>", "log-armor");
        }

        initGame();

    </script>
</body>
</html>
